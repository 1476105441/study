# 查漏补缺

还需要学习的知识：HTTPS、分布式协议、计算机网络和操作系统还需要深挖



# 计算机网络

## 1、什么是CSRF？
​	CSRF，全称为跨站请求伪造，是一种常见的网络攻击手段，他是利用网站对用户浏览器的信任来达成恶意攻击的。一般的场景是恶意网站返回给用户的网页中包含一个重定向的请求（亦或是包含请求的按钮），如果用户访问了恶意网站，那么浏览器就会携带用户的cookie向重定向的目标发起请求，就可以完成一次恶意攻击（转账操作或者其他损害用户的操作）。


## 2、什么是Oauth2.0协议？有哪几种认证方式？什么是JWT令牌？和普通令牌有什么区别？

​	Oauth2.0是一个开放标准，允许用户授权第三方应用程序访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。



## 3、什么是XSS攻击？怎么预防XSS攻击？

​	XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。比如，用户自己填写的某些信息中，恶意用户填写的是一段JavaScript代码，当其他用户查看他的信息时，就会获取这段JavaScript代码，然后浏览器就执行了这段恶意代码，从而达到了恶意窃取用户信息等行为。

​	预防XSS攻击：

* 设置cookie为http only，这样JavaScript代码中就无法获得cookie的内容了，从而防止了用户信息被窃取。
* 对用户上传的数据进行过滤，过滤掉潜在的风险。



## 4、什么是HTTPS？和HTTP有什么区别？HTTPS的连接过程？

HTTP：

* 以明文方式发送内容，不提供任何方式的数据加密。



HTTPS：

* 在HTTP基础上加入了SSL/TLS协议，依靠证书验证服务器身份，并且为浏览器和服务器之间的通信加密。



## 5、TCP是如何保证可靠性的？TCP的可靠数据传输原理？

​	由于底层的网络传输信道是不保证数据传输的可靠性的，所以需要在传输层来做相应的可靠传输的保证。TCP通过checksum保证传输的报文不在网络传输过程中出现bit位错乱，通过超时重传机制来应对报文丢失的情况发生，通过流量控制来控制发送端发出报文的速率，通过拥塞控制来避免网络过于拥堵以至于出现崩溃的情况发生。

​	TCP的可靠数据传输原理：TCP是基于滑动窗口协议来发送报文的，也就是在发送端和接收端都设有缓存，下面进行详细的介绍。

​	滑动窗口协议：

* GBN协议：发送端的发送缓存可以同时发送多个分组，接收端的接收缓存只能接收一个分组，如果报文乱序到达接收端，则直接抛弃，也就是不支持乱序接收分组。当触发超时重传机制时，需要将发送窗口中所有分组重新发送，ack是累计ack，也就是对最近接收到的分组的ack。定时器只针对发送窗口中最早的分组进行设置。
* SR协议：发送缓存和接收缓存都可以同时处理多个分组，对于在接收窗口中的分组单独发送ack，发送窗口中的每个分组单独维护ack和定时器。超时重传只需要重传发送窗口中没有收到ack的分组，所以叫做选择重传。
* 两种协议比较：
  * GBN协议：**优点**是维护简单，只需要设定一个定时器，接收方只需要一个接受缓存。**缺点**是出错时需要将发送窗口中的所有分组都进行重传，代价太大。
  * SR协议：**优点**是出错时重传的代价小。**缺点**是对于发送窗口中的每一个分组，都要单独维护定时器，实现起来复杂，所需资源多，接收窗口可能需要缓存多个分组。



​	TCP实现的滑动窗口协议：结合GBN和SR协议进行改进。

* 发送缓存和接收缓存可以同时接收多个分组。
* 采用累积确认，如果收到乱序到达的分组，发送当前接收窗口中最低的已确认分组的ack。
* 快速重传机制：发送方如果收到3个冗余ack，则立即重传当前最低位的分组。
* 产生ack的细节：如果接收方接收到所期待的按序报文到达，并且所有之前的报文已经确认，则发送ack采用延迟策略，会延迟500ms，等待下一个顺序到达的报文（因为是累计确认，这样可以一次确认多个报文了）。如果等待期间另一个按序报文到达，则立刻发送ack，以确认两个报文段。
* 超时重传又与GBN不同：设当前报文段为n，如果当前定时器超时，GBN协议会重传n以及后续的所有报文段，而TCP协议至多只会传输一个报文段，即报文段n。



​	**流量控制**：

* 为什么要有流量控制？TCP协议是发送方和接收方都有缓存的，接收方的应用程序从接收缓存中读取所需要的数据，但应用程序不一定是接收缓存一接收到数据就进行读取了，也有可能过了很久才来处理这些数据，由于接收缓存是有限的，如果接收方应用程序的读取速度很慢，而发送方发送的太多，太快，就会导致接收方的接收缓存溢出。流量控制服务就是为了避免接收缓存的溢出而出现的机制。
* 流量控制是如何做到的？接收方通过TCP头部的一个字段（接收窗口）来告诉发送方，自己当前能接收的最大流量是多少。



## 6、有了TCP为什么还需要UDP？

​	因为UDP更快，UDP提供的是尽力而为的服务，不提供可靠性、流量控制、拥塞控制。

UDP更快体现在：

* 应用程序交付多少报文，就发出去多少报文，无拥塞控制和流量控制，不需要考虑网络拥堵情况。
* 不建立连接，减少了建立连接所需要的时间。
* 维护简单，发送方和接收方不需要维护连接状态。
* 报文段头部很小，开销小，一个报文段所能承载的信息也就更多。



## 7、TCP建立连接为什么是3次握手，而不是2次握手、4次握手？

​	首先，tcp建立连接的时候，客户端会和服务端交换字节序号，这个字节序号具有重要的作用。

​	如果是2次握手，那么服务器在向客户端返回字节序号信息时就已经当做连接建立了，此时就会有个问题：如果是由于网络阻塞或其他网络原因导致的客户端发出的历史连接请求现在才到达服务器端，而此时这个客户端已经关闭了连接（或者说不需要再和服务端建立连接了），那么服务端仍然会将这个连接请求当做正常的连接请求来处理，为这个连接维护资源。**这样就会导致服务器资源的浪费**。

​	如果是4次握手，其实没有必要，在3次握手时，服务端就已经可以得知客户端状态良好，并且是愿意建立连接的。已经能够确保服务器维护资源是有用的，所以没必要再多进行一次握手了。



## 8、TCP关闭连接为什么是4次挥手，而不是3次挥手？

​	由于TCP连接是全双工的，当客户端想要断开连接的时候，服务端可能还有数据要传送给客户端，所以整个断开连接的流程应该是客户端发起关闭连接请求，服务端收到并返回一个ack，同时服务端可以关闭自己的接收缓存（因为客户端不会再发送请求了）。如果服务端还有数据要发送，则等到发送完数据，服务端再向客户端发送关闭连接的请求，然后等待客户端返回ack，就可以彻底关闭连接了。而客户端这边，收到服务端关闭连接的请求后，需要再等待一段时间，防止由于网络传输出现问题导致服务端没有收到自己的ack。一段时间后，客户端没有再收到服务端的关闭连接请求（因为可能有超时重传情况出现），确认服务端已经收到自己的ack，彻底关闭连接。

​	为什么不能是3次握手？因为最后的时候服务端必须收到ack的确认之后才能关闭连接，不然无法确保客户端正确的接收到了自己发送的关闭连接请求。



## 9、为什么TCP被称为面向字节流的协议？UDP呢？

​	因为TCP协议构造报文时，将应用程序交付过来的数据视为字节流，并不为每个应用程序设置边界，不同的应用程序的数据有可能被构造成一个报文，这也就是所谓的**粘包**问题。

​	UDP是面向报文的协议，应用程序交付给UDP的报文，UDP只是在报文基础上加上一个头部，然后就交给下层了，不会对消息进行拆分，也就是说，应用层交给UDP的数据多长，UDP就发出多长，当然UDP的头部不算在内。

​	那如果应用层交付下来的数据非常的长，那UDP还是视为一个报文发出去吗？网络能够一次发这么多报文吗？需不需要限制应用层发下来的数据大小呢？

​	只要不超过理论上的限制（65507字节，后面单独开个问题解释），就可以视为一个报文发送出去，最底层一次发送的帧可能达不到那么多，但是在ip层的时候，就会将上层的数据进行分片了，所以UDP不需要考虑能否发送的问题，交由其下层实现。



# 数据结构与算法

## 1、什么是并查集？并查集能做什么？

​	我的理解：并查集是一种数据结构，它可以帮助我们将元素归为多个组，用以区分不同的元素组。

​	百度百科：并查集是一种树型的数据结构，用于处理一些不想交集合的合并及查询问题。



## 2、什么是单调栈？单调栈能做什么？
我的理解：
* 单调栈是一种特殊的栈数据结构，特殊之处在于它其中存储的元素都是按照一定的策略，单调增/减的。
* 典型的考察单调栈的题目有《滑动窗口的最大值》



## 3、什么是树状数组？树状数组能做什么？
我的理解：
* 树状数组是一种按照特殊策略维护的前缀数组，由于其维护方式很像是树形，但实质上是使用数组结构，所以一般称为数组。
* 树状数组用于动态维护前缀和，比如当我们的需求需要频繁的修改前缀和，如果使用传统的数组来进行更新的话，时间复杂度是O(n)，修改一个元素，那么这个位置以及后边的所有位置的前缀和都需要修改。如果使用树状数组的话，能够将时间复杂度减低到O(logn)级别。


## 4、什么是线段树？线段树能做什么？



## 5、什么是拓扑排序？



## 6、什么是差分数组？





# 操作系统

## 1、操作系统是如何保证多个线程之间不会相互访问到彼此的内存的？

​	每个线程都有自己的栈内存，如果是使用局部变量的话，局部变量只能保存在栈内存中。



## 2、操作系统是怎样为每个线程分配一个栈的？



## 3、什么是LRU算法？如何实现LRU算法？如何优化？

​	LRU（Least Recently Use），中文意为最近最少使用算法，常用于缓存替换策略，将最近一段时间内最少使用的缓存内容换出。

​	**LRU的简单实现**：使用Hash表+双向链表，Hash表中存放当前缓存中拥有的数据，在双向链表中存放这些数据添加进来的顺序，如果缓存命中了，则更改它在链表中的顺序，调整为队头；如果缓存满了，此时还需要加入新的缓存，则淘汰掉队列尾部的缓存内容。

​	**优化**：

* LRU-K：采用LRU-K改进LRU算法，LRU-K的实现是使用两个队列，一个是缓存队列，一个是访问数量统计队列，访问某个内容之后，并不是直接将其加入到缓存中，而是将其加入到数量统计队列中，当访问数量达到K次后，再将其放入到缓存队列中。而数量统计队列的维护也是有上限的，其也采用LRU算法淘汰太久没有被访问过的数据。
	 * 为什么要访问数量达到K次后才放入到缓存队列中？因为这样做可以避免缓存污染，比如某一个请求需要查询出所有的数据，而这些数据并不是接下来将会经常访问的数据，导致缓存内容会被频繁的换出，这就是缓存污染。
	 * 缺点是需要额外维护一个统计队列，占用系统资源。
	 * 综合来说，使用LRU-2性能最优，为什么？
* Two Queue：和LRU-K基本上一样，是LRU-2的变种，数量统计队列采用FIFO算法，而不是LRU，实现更简单，消耗资源少，但相比于LRU-2会降低缓存命中率。
* Multi Queue：也可以看作是LRU-K的变种，只是将两个队列增加至了多个队列，每个队列的优先级不同，首次访问数据时，数据会被添加到最低优先级的队列中，每个队列中同样采用LRU，当数据的访问次数达到一定时，将会”晋升“至更高优先级的队列中，而访问次数不达标时，还会从当前队列降级到第一级的队列中。除此之外，还有一个额外的队列（Q-history）用来存储即将被淘汰的数据，淘汰总是从最低级的缓存队列进行的，当缓存队列满了的时候，会将队尾数据加入到Q-history中，当Q-history中的数据被再次访问时，会计算其的优先级，然后加入到相应优先级的队列中。
* MySQL中的LRU：在MySQL中，数据（一行记录）是以页为单位存储的，读取到内存缓冲区的时候也是以页为单位来读取（可能？），由于MySQL在内存中的缓冲区大小是有限的，所以也需要使用LRU算法来缓存页。不过MySQL中使用的LRU相比于普通的LRU更为特殊，用语言描述，它更像是一种冷热分离的LRU算法，因为它的LRU实现时访问数据后，并不是将数据插入到链表的头部，而是插入到链表的midpoint位置，这个midpoint是由MySQL的参数innodb_old_blocks_pct控制的，默认配置下，是在链表长度的5/8处。在Innodb存储引擎中，把midpoint的列表称为new列表，后面部分的列表称为old列表。
   * 为什么要采取这样的一种插入策略呢？因为在MySQL中，没有使用索引的全表扫描（即使使用了索引，也有可能需要访问大量的数据页），会需要访问大量不同的数据页，从而将缓冲中很多数据都刷新出缓存，后续不能再命中这些缓存。为了解决这个问题，innodb存储引擎还引入了另外一个参数来进一步管理LRU缓存：innodb_old_blocks_time，这个参数表示在页加入midpoint多少时间之后，再将页放入到链表的头部。因此，我们可以使用这个参数来解决全表扫描造成大量有效页被刷新出缓存，例如，在进行全表扫描的查询操作之前，将innodb_old_blocks_time设置为一个很大的数，这样midpoint之前的数据都不会被刷新出缓存，在全表扫描完成之后，再将innodb_old_blocks_time参数设置回适合的值。



## 4、什么是高速缓存的局部性原理？

​	**我的理解**：

* 时间局部性：由于循环的存在，内存中访问过的指令可能在不久的将来就会再次访问到。
* 空间局部性：内存地址中相邻的指令或内存很可能也会被访问到，比如遍历数组、顺序执行程序。

	综合这两点来说，我们的程序执行时，很可能在某段时间内，执行的是同一段内存地址中的指令或访问的是同一段连续的内存，所以，我们可能只需要很小的一块高速缓存，也可以做到高速的执行。
		
	**CSAPP**:
		
	程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。
		
	**存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。**



## 5、什么是进程？线程？协程？它们有何区别？

​	**我的回答**:

* 我觉得进程就是运行中的程序，操作系统为了更好的管理这些程序，并且要做到同时执行多个程序，所以操作系统使用一个数据结构PCB来定义正在执行的程序，这个数据结构保存当前程序执行的信息，还有操作系统分配的资源，比如页表、PC寄存器的值，都会保存在PCB中。一个PCB就代表了一个正在执行中的程序，也就是一个进程。
* 对于每个进程，操作系统都会分配内存资源，进程在上下文切换时的开销就会很大。为了减少上下文切换的开销，就引出了线程的概念，一个进程中可以包含多个线程，这多个线程共享这个进程所分配的内存空间，所以线程切换的时候开销小，可以将更多的时间用在执行程序上。
* 线程的切换，需要进入内核态执行，虽然相比于进程来说，线程的切换开销比较小，但是依然需要使用很多的系统资源，所以，这时候引出了协程，协程是运行在用户态的，所以操作系统感知不到协程的存在，多个协程可以跑在一个线程之上，而协程的切换只需要在用户态做处理，切换开销极小。
* 对于每个进程，操作系统都会为其分配内存和其他系统资源，也就是说，每个进程之间的系统资源和内存是独立的；而多个线程是共享一个中的内存和系统资源的，有可能造成安全问题；相比于线程，协程可以由程序员自己进行负责调度，避免了无意义的调度，并且更加轻量级，由此可以提升性能，但协程不使用于阻塞IO的场景，因为阻塞时，当前线程进入内核态，操作系统并不知道协程的存在，会将这个线程阻塞住，切换到别的线程执行，而运行在这个线程之上的所有协程都将会被阻塞住，无法运行。
* 总结来说，进程主要负责资源的保护和管理，线程主要关注中央处理器的执行，而协程则是更近一步提高并发执行能力。



​	**知乎链接**：

* 什么是协程：https://zhuanlan.zhihu.com/p/172471249



## 6、什么是保护模式和实模式？为什么要使用保护模式？

​	**我的回答**：计算机刚开始启动时，需要执行初始化代码，初始化代码一般存在内存中0xFFFF0处，此时CPU处于实模式，寻址方式为CS（段寄存器）左移4位+IP。而进入保护模式之后，不再是直接通过CS+IP的方式来寻址，而是使用gdt表进行地址翻译，使用idt表处理中断指令，具体的做法是使用CS寄存器中的值去gdt中查找对应的记录项，然后再和IP组合起来形成物理地址。

​	使用保护模式的好处是能够实现更大的地址空间和更灵活更安全的内存访问，例如可以在gdt表中存放一些标识，来判别当前程序是否能够访问此内存地址以及其他的一些控制信息。



## 7、操作系统怎样判断是否进入了保护模式？

​	使用cr0寄存器来判断，cr0寄存器的最低位标识是否进入了保护模式，如果是1的话，表示启动了保护模式，否则是未启动。同时cr0寄存器还有另一个作用，它的最高位标识是否启动分页，如果为1表示启动分页。



## 8、计算机是怎样启动的？

​	首先，刚开机时CPU处于实模式，CS=0xFFFF，IP=0x0000，寻址0xFFFF0（ROM BIOS）处执行初始化代码，检查RAM，键盘，显示器，软硬磁盘等工作，然后将磁盘0磁道0扇区（引导扇区）读入到0x7c00处，然后跳转到引导扇区代码bootsec中执行，在bootsec中，将setup模块和system模块读入到内存中，然后进入setup执行，setup模块中完成OS启动前的设置，包括设置内存大小，各种硬件参数等等，便于后续操作系统管理硬件，然后setup模块将system模块移动到0地址处，并且设置gdt表，操作系统即将进入保护模式，保护模式的寻址方式和实模式不同。然后跳转到system模块运行，首先干的一件事就是再次初始化gdt和idt表，然后初始化页表，进入main函数执行一系列初始化，包括内存、中断、设备、时钟、CPU等内容的初始化。



## 9、什么是操作系统接口？

​	操作系统接口就是操作系统提供给上层应用程序调用的函数，屏蔽了驱动硬件的细节，让应用程序开发人员能够方便快捷的使用操作系统提供的功能。



## 10、为什么操作系统要分用户态和内核态？如何区分内核态和用户态？用户程序如何进入内核模式执行所需的代码?

### 为什么区分：

​	首先，用户态和内核态是什么？用户态就是程序员们开发的应用程序运行时使用的内存地址空间，而内核态是操作系统运行所使用的的内存地址空间，内核态中存放了很多管理电脑使用的数据结构和数据，如：PCB、FCB、内存表（mem_map）、内存大小参数等等。

​	为什么要将应用程序和操作系统分开？如果没有区分用户态和内核态，那么一个应用程序就可以随意的访问到所有重要的系统资源信息，也可以随意的篡改这些系统信息，不安全。试想一下，如果多个用户同时操作一台计算机，而没有区分用户态和内核态的话，用户A操作的数据在内存中，而用户B可以访问这些数据，同时所有用户都可以看到存在内存中的操作系统数据，包括每个用户的信息等等。

### 如何区分：

​	使用CS寄存器的最低两位（CPL）来表示当前是在用户态还是在内核态中，0是内核态，3是用户态，而目标内存地址的段寄存器值的最低两位为RPL。在保护模式下，对于要访问的内存地址，需要查询GDT，而在GDT中会记录目标内存地址的DPL（Descriptor Privilege Level），每一次访问内存地址时，都需要进行特权级检查，只有当DPL>={CPL,RPL}时，才允许进行访问。

### 用户态如何进入内核态执行：

​	对于Intel x86，使用中断指令int，可以进入内核态执行，int指令将CS中的CPL改成0，从而就可以进入内核了，这是用户程序进入内核态执行的唯一方式。



## 11、什么是系统调用？系统调用有什么用？系统调用是怎么实现的？

​	系统调用就是操作系统提供给应用程序使用的功能接口，例如读取文件、创建线程，由于这些功能是由操作系统实现的，而开发应用程序需要使用这些功能，所以操作系统提供了系统调用这样的接口给应用程序使用。

​	系统调用使用户程序能够进入内核态执行操作系统代码，而且用户程序只能通过系统调用才能进入内核态执行。这是因为操作系统需要保证计算机运行的安全，如果用户程序能够随意进入内核执行，随意的访问底层数据，调用底层方法，那么就有可能有恶意分子随意更改其他用户的文件信息。

​	操作系统通过段寄存器CS的低2位来判断当前执行的程序是处于用户态（值为3）还是内核态（值为0），这个信息叫做**特权级**，只有当特权级为内核态时，才能够跳转到内核态中的目标代码中执行。每当执行函数调用的时候，都需要判断当前代码的特权级和目标代码的特权级是否符合符合要求，如果不符合要求，则不允许跳转执行。而系统调用通过idt表来进行函数跳转（保护模式），而idt表中的特权级设置为3，这样，即使是处于用户态的程序也可以跳转到这个函数中执行。



## 12、gdt、ldt、idt分别是什么？为什么需要它们？

​	gdt是全局描述符表，主要是用于保护模式中进行地址转换时使用。段表的作用有：权限控制（特权级判断）

​	ldt是局部描述符表，是每个进程独有的段表，因为进程之间的内存是相互隔离的，每个进程都有自己的代码段、数据段等，所以每个进程都要有自己的段表。

​	idt是中断向量表，是执行中断指令时需要查询的。



## 13、CS:IP和PC寄存器有什么区别？

​	网络上也没有详细对比这两者的文章，但是有文章说CS:IP用于寻址，而PC是不同厂商对这种寻址寄存器的称呼。

​	我个人的理解是，这两种寄存器在功能没有区别，都是完成指令寻址功能，而在具体的实现上有所区别。



## 14、按位编址和按字节编址有什么区别？

​	按位编址表示一个数字代表一个位，而按字节编址表示一个数字代表一个字节，使用字节编址，使用更小的数字能够表示更大的内存。



## 15、CPU调度算法的性能评价标准是什么？各评价标准的影响因素是什么？

​	**CPU利用率**：CPU有效执行的时间/总时间。如果频繁的发生线程上下文切换，那么CPU很大一部分的时间都花费在切换上了，而没有使用在运行程序上。

​	**周转时间**：批处理用户从作业提交开始，到作业完成为止的时间称为作业周转时间。

​	**吞吐量**：单位时间内系统完成的任务数量。对于很多批处理程序来说，吞吐量越大越好。

​	**响应时间**：用户提交一个请求到接收到响应之间的时间称为响应时间。



## 16、CPU调度算法是什么？为什么需要？有哪些CPU调度算法，各自的优缺点是什么？

​	**是什么**：CPU调度算法是CPU执行线程/进程上下文切换时挑选线程/进程使用的策略。

​	**为什么**：好的CPU调度算法能够极大的提升计算机性能，或者给用户更好的体验，由于计算机的使用范围极为广泛，不同的使用场景使用不同的调度策略能够更好的利用计算机。

​	**有哪些**：批处理系统的调度算法：先到先服务（FCFS）、短任务优先（SJF）、响应比优先。分时系统的调度算法：时间片轮询、多级反馈队列。

- 先到先服务

  - 优点：实现简单，消耗资源少。
  - 缺点：适用性差，比如，当前计算机的使用场景是用户使用，那么它应该要给用户良好的使用体验，即对用户的响应要快，这时如果有一个耗时很长的后台任务来了，那么它将会占用cpu很久，以至于用户已经等的不耐烦了。简单来说，任务如何执行，完全取决于任务提交的时机，这是非常不可控的。

- 短任务优先

  - 估计运行时间短的任务优先被调度。

  - 优点：适合需要高响应的使用场景。
  - 缺点：会出现饥饿现象，如果不断的有短任务提交，那么耗时较长的任务将会得不到执行机会，这是一个致命缺陷。不适合科学计算等需要高吞吐量、高利用率的场景，因为短作业优先算法会频繁的发生上下文切换，即使线程的切换代价相比于进程切换已经小了很多，但依然是一笔不可忽视的开销。

- 响应比优先

  - 结合等待时间和估计耗时，计算公式为：响应比 = 1 + 等待时间/估计运行时间。
  - 优点：不会出现饥饿现象，又保证了短任务优先执行，估计运行时间越小，响应比越高，所以就越先执行；而估计运行时间长的任务，随着等待时间的增加，响应比也会越来越大，最终额能够获得执行机会。
  - 缺点：以周转时间作为性能的衡量标准的话，响应比优先调度算法的性能是介于短作业优先和先来先服务之间的。

- 时间片轮询

  - 给每个进程分配一个执行时间片，然后按照先到先得的顺序执行，时间片消耗完后将执行权交给下一个进程，如果任务没有执行完，重新进行排队。
  - 优点：实现简单，每个进程都有同等的运行时间，都有机会获得执行机会，不会出现饥饿现象。
  - 缺点：对于所有的进程一视同仁，特定场景下执行没有优势；进程频繁切换，执行效率不高。

- 多级反馈队列

  - 在时间片轮询的基础上设置多个就绪队列。1、每个就绪队列的优先级不同，不同队列中的进程有不同的时间片优先级越高的队列，拥有的时间片越短。2、在就绪队列中使用先到先得的调度算法，而最后一个就绪队列采用时间片轮询算法。3、不同就绪队列中采取抢占式调度，如果当前进程执行时，有新的进程进入了优先级更高的就绪队列中，则新进程夺走当前进程的执行权，当前进程进入下一个就绪队列中执行。4、新创建的进程总是从优先级最高的就绪队列开始执行，如果时间片用完了，进程任务还没执行完，则进入下一级就绪队列中等待执行。
  - 优点：适用于不同情况，能使各类用户获得较为满意的性能。
  - 缺点：实现复杂。



# 分布式

## 1、CAP是什么？

​	C：Consistency，一致性

​	A：Availability，可用性

​	P：Partition Tolerance，分区容错性

​	CAP理论：一个分布式系统不可能同时很好的满足一致性、可用性、分区容错性这三个需求。



## 2、Eureka的自我保护机制是什么？

​	是指短时间内，出现了Eureka与大量的服务联系不上（90秒没有收到心跳包）的情况下，Eureka选择不删除（下线）这些服务。这是因为短时间内如果出现大量的微服务下线，则有可能微服务本身没有问题，而是由于网络分区的故障（可能是当前Eureka服务器的网络出现了问题），导致服务暂时不可用，Eureka为了确保高可用，宁可保留着错误的服务，也不会随意下线服务。**属于CAP中的AP分支**。



## 3、什么是服务雪崩？该如何解决？

​	这篇文章讲的应该还不错：https://www.jianshu.com/p/acfb4ac2b124。

​	服务雪崩是由于服务提供方不可用或响应慢，导致服务调用方不可用或响应慢，并且影响逐渐扩大的情况。我的理解是：由于服务中的一个接口出了问题，导致整个服务不可用，从而导致其他调用此服务的服务也不可用，就像雪崩一样。

​	解决方案：**服务熔断**、**服务降级**。使用”断路器“，当某个服务发生故障之后，通过断路器的检测，向调用方返回一个符合预期的、可处理的备选响应，而不是长时间的等待或者抛出调用方无法处理的响应，这样就保证了调用方的线程不会被长时间、不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。



## 4、什么是服务降级？服务熔断呢？

​	服务降级：服务器繁忙或出现异常，为了不让客户端等待，立即返回一个友好提示。

​	服务熔断：在一段时间内，服务器多次请求超时或出现异常，则对接下来的请求无需等待，直接调用服务降级的方法返回友好提示。

​	我的理解：服务降级就相当于提供一个兜底的方法，一般情况下，只有请求的服务出现了异常或者超时，才需要进行服务降级。而服务熔断的时候，不管当前请求会不会出现异常，都直接按照服务降级来处理。

​	**案例：**服务提供者B提供两个接口，一个正常返回结果，一个等待3秒后返回结果（模拟服务响应慢导致请求超时），服务消费者A可以调用服务提供者B的两个服务，此时使用测压工具模拟大量并发请求去请求服务B的超时接口，将会导致服务B的线程池被占满，从而导致服务B的其他服务也不可用，这时候再使用服务A去调用服务B，服务A也会陷入等待，直到超时。最终的结果就是服务A也被拖垮了，这就形成了上面的服务雪崩的情况，此时应该使用服务降级来避免这种情况的发生，在服务A请求服务B未果后，应该返回一个兜底的方法处理结果，而不应该继续等待。



## 5、服务提供和服务消费使用Hystrix的区别？

​	**服务提供方：**需要在业务方法上加上@HystrixCommand注解，然后在主启动类上添加@EnableCircuitBreaker注解进行激活

​	**服务消费方：**在YML配置文件中进行配置

~~~yml
feign:
  hystrix:
    enabled: true #如果处理自身的容错就开启。消费端开启方式与生产端不一样。
~~~

​	然后在主启动类上添加@EnableHystrix注解，最后在业务方法上添加@HystrixCommand注解。



​	**服务调用方使用服务降级的不同方法**

* 在业务代码中使用@HystrixCommand，业务controller上使用@DefaultProperties指定默认的兜底方法。
  * 缺点：和业务代码耦合在一起，维护起来很麻烦。
* 编写feign接口的实现类，在实现类中位调用方法提供兜底方法，然后在父接口@FeignClient注解中指定fallback属性为实现类。
  * 缺点：这种方法是不是要给每个方法都提供一个兜底方法？那就太麻烦了。



## 6、Hystrix断路器工作原理？

​	Hystrix断路器会在一定时间内（时间窗）统计请求失败的次数，当这段时间内的请求次数达到了阈值，并且请求失败的比例超过了规定的比例，则断路器打开（注意这个打开的意思是断路器开始工作），接下来一段时间（休眠窗口）内的所有请求都直接走服务降级流程，过了一段时间后（休眠窗口），断路器进入半开状态，会放一条请求去实际调用服务，如果这次请求成功了，则服务恢复了正常，断路器关闭（停止工作）；如果失败了，断路器继续工作，直到下一个周期再放一条请求进来，重复这个步骤。

​	断路器的三个状态：打开、半开、关闭。服务正常时，断路器的状态是关闭的；当一定时间内，请求数量达到阈值，请求失败比例达到阈值，断路器进入打开状态；进入打开状态一段时间后（休眠窗口），进入半开状态，服务有机会恢复成正常状态。



## 7、分布式微服务项目中网关的作用是什么？为什么选择Gateway而不选择Zuul？

​	能够进行反向代理（分发请求给具体某个服务实例）、权限校验、流量监控、服务熔断、日志监控等功能。

​	为什么选择Gateway：

* Zuul1.0已经进入了维护阶段，而Gateway是springcloud团队研发的，功能更多，用起来也方便。而Zuul2.x版本SpringCloud似乎并没有整合计划。
* SpringCloud Gateway具有的特性：动态路由、可以对路由指定断言和过滤器、集成了Hystrix的断路器功能、集成服务发现功能、请求限流功能、支持路径重写。
* Zuul1.x是一个基于阻塞I/O的API网关，基于Servlet2.5，不支持任何长连接，性能较差；SpringCloud Gateway使用非阻塞I/O，支持WebSocket。



## 8、向微服务项目发送请求，请求的处理过程是什么样的？网关和服务调用方的区别是什么？

​	请求应该是先到达网关，然后网关再进行动态路由，将请求分发给对应的微服务。

​	一开始我以为服务调用方是微服务对外暴露的，但实际上对外暴露的应该是网关才对，也就是说，网关和我前面所学的例子中的服务消费者的作用是一样的。我的理解是：在微服务项目中，由于各个服务之间需要相互调用，所以每个微服务可能即是服务调用者，也是服务提供者，而最开始我认为的服务调用者的身份，其实是网关来充当的。



## 9、SpringCloud Stream是什么？有什么作用？

​	为了解决项目中使用到多种不同的消息中间件的时候，不同的消息中间件处理起来是完全不同的，如果要迁移的话，一大堆东西都要推到重做，因为具体的发布和订阅代码和我们的系统耦合了，这时候使用SpringCloud Stream，可以帮助我们消除这种耦合。

​	SpringCloud Stream通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。



## 10、什么是漏桶算法？

​	漏桶算法是网络世界中流量整形或速率限制时常用的一种算法，它的主要目的是控制数据注入到网络中的速率，平滑网络上的突发流量。



## 11、为什么要使用消息队列？什么情况下应该使用消息队列？



## 12、Seata是怎么做到保证分布式事务的回滚和提交的？

### Seata主要构成	

Seata分布式事务处理过程：ID+三组件

* 全局唯一的事务ID：Transaction ID，XID。
* Transaction Coordinator(TC) ：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。
* Transaction  Manager(TM) ： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。
* Resource Manager(RM) ：控制分支事务，负责分支注册，状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。

![image-20221129174218151](D:\文档\学习笔记\学习疑问.assets\image-20221129174218151.png)

![image-20221129203014342](D:\文档\学习笔记\学习疑问.assets\image-20221129203014342.png)

### 分布式事务的执行流程

1、TM开启分布式事务(TM向TC注册全局事务记录)。

2、换业务场景，编排数据库，服务等事务内资源（RM向TC汇报资源准备状态）。

3、TM结束分布式事务，事务一阶段结束（TM通知TC提交/回滚分布式事务）。

4、TC汇总事务信息，决定分布式事务是提交还是回滚。

5、TC通知所有RM提交/回滚资源，事务二阶段结束。



## 13、Redis分布式锁和Zookeeper分布式锁有什么区别？

* 机制不同：redis分布式锁是基于键值对设立的，类似于Set集合，利用Set的去重性，使得同一资源只能有一个用户获得。同时Redis分布式锁需要配合luo脚本做到原子性更新。而zookeeper是类似于监听器机制实现的分布式锁。
* 死锁解决方案不同：redis是通过设置过期时间来减少死锁带来损害，一段时间内自动放弃锁的持有权。而zookeeper是基于会话有效期来解决死锁问题，当会话断开时就会自动释放对锁的持有权。
* 在集群模式下使用分布式锁，zookeeper比redis稳定，而性能没有redis好（redis是将数据存储在内存中）。为什么zookeeper更加稳定？因为zookeeper采用的是2PC一致性协议，保障了一致性。





# Java基础

## 1、Java里HashMap长度为什么是2的次幂？

* 如果长度是2的次幂的话，可以让数据更散列更均匀，能够更充分的利用数组空间。
* 方便操作，如果长度都为2的次幂的话，扩容迁移的时候不需要再重新通过哈希定位新的位置。



## 2、HashMap中链表达到一定长度后为什么要变为红黑树？何时会将链表结构改成红黑树？

​	红黑树的查询效率高，能够提升效率。还能一定程度上缓解DDos攻击，当攻击者发送大量相同hash值的对象，往hashMap中存放，如果使用链表，会造成性能直线下降，改成红黑树结构，能够一定程度上抵御这种攻击。

​	当链表长度达到8时，当hash表数组的长度没有达到64时，会先尝试扩容hash表，因为扩容之后原来一个链表上的元素会分散到其他节点上。当hash表数组长度达到64时，就会将链表改为红黑树结构。

​	当红黑树长度小于6时，会将红黑树结构还原为链表。



# 并发

## 1、为什么要使用线程池？



## 2、volatile关键字有什么作用？应用上对volatile的应用举例？

​	volatile关键字可以解决可读性、有序性问题。两阶段终止时，如果没有指定判断的变量为volatile，则有可能造成可读性问题。



## 3、什么是指令重排序？指令重排序会造成什么影响？

指令重排序分为：编译器重排序、CPU重排序、内存重排序。

**我的回答**：**编译器重排序**是指编译器在将高级语言编译成机器代码时，可能会对程序所做的优化，将一些顺序执行的指令重新排序。	**CPU重排序**：这其中也有CPU执行指令的流水线模型这个因素的影响，CPU将一条机器语言指令的执行又拆分成了很多小步骤，比如：取指、译码、执行、访存、写回，不同的指令可能某些小步骤的执行可能会有冲突，所以编译器会调整指令的顺序（在允许执行的情况下）。

**我的回答**：指令重排序并发场景下会造成可读性问题。



## 4、什么是Monitor？

​	Monitor被翻译为监视器或管程，使用synchronized给对象上锁之后，这个对象的对象头（Mark Word）中就会包含指向一个Monitor的指针（其实就是Monitor的内存地址），所以Monitor充当的其实是一个锁结构的角色。其中有三个主要组成部分：wait set（等待集合，用于存放在此对象上等待条件变量的对象）、entry list（阻塞队列，在阻塞队列中的线程相互竞争获取锁的权利）、owner（当前锁的持有者）。



## 5、什么是锁升级？

​	几个重要概念：轻量级锁、重量级锁、偏向锁。

### 轻量级锁

​	**特点**：不涉及Monitor。

​	**使用场景**是对象有多个使用者，但是这些使用者的使用时间是错开的，此时可以使用轻量级锁，避免开销过大。

​	**实现原理**

* 在每个线程的栈帧中维护锁记录结构，这个锁记录主要有两个重要组成部分：对象地址、锁记录地址（包含锁状态，最低两位是00），加轻量级锁时，会将锁记录地址和对象头中的Mark Word进行cas操作，cas成功则说明轻量级锁加锁成功；否则加锁失败，有两种情况：一个是当前对象锁已经被其他线程持有了，接下来将会进行锁膨胀（锁升级），二是当前对象锁被当前线程持有，说明发生了锁的重入，会在当前线程的栈帧中再生成一条锁记录。
* 解锁时如果锁记录的记录地址处为null，说明此记录为一条重入记录，这时重置锁记录（意思是找到下一个锁记录）；如果不为null，则再次使用cas和对象的Mark Word交换，如果交换失败，说明发生了锁膨胀，则进入重量级锁的解锁流程。

### 重量级锁

​	即使用Monitor，在使用重量级锁的情况下，内存中的结构是这样的：线程对应的栈帧中的锁记录指向对象，对象头中的Mark Word指向Monitor对象，而Monitor中的owner属性指向线程（锁记录？）。

### 偏向锁

​	在某些情况下，可能大部分时间里都只有一个线程反复给一个对象加锁，这时候如果使用轻量锁，每一次加锁过程都需要CAS操作，比较浪费，这时候就引出来了偏向锁，严格来说偏向锁并没有加上锁，只是在对象的Mark Word加上了线程标识，表明当前有线程正在使用。

​	偏向锁的撤销情况：

* 调用了对象的hash code方法时，会撤销掉当前对象上的偏向锁，因为hash code是存储在对象头中的Mark Word中的，使用轻量锁时，hash code通过CAS保存到线程锁记录中；使用重量锁时，hash code保存在Monitor中。
* 有其他线程加了偏向锁，当前线程检查到其他线程加了偏向锁，会将偏向锁升级为轻量级锁。
* 调用wait/notify会升级为重量级锁，只有重量级锁才支持重量级锁。



## 6、什么是可见性、有序性、原子性？怎么保证这些特性？

​	可见性：在多线程并发的场景下，由于CPU的结构，多个线程并行执行的时候会使用独立的缓存，有可能线程1对内存中的某个数据进行了修改，由于线程2将内存这个数据的值读取到了自己的缓存中，所以线程2后续使用的时候读到的是缓存中的数据，并不是被修改的在内存中的最新数据，这就造成了数据不可见的问题。

​	有序性：jvm可以在不影响程序正确性的情况下，对指令进行重排序，详见第三个问题。在多线程并行的情况下，有可能造成程序执行结果不符合预期。

​	原子性：高级语言层面的指令在实际执行的时候可能分为多条机器指令，这些机器指令应该作为一个整体来执行，而现实情况是在执行这一系列的机器指令时，由于调度机制，可能会切换到别的线程执行，使程序的运行结果出问题。

​	使用volatile可以解决可见性、有序性问题，但无法解决原子性问题。使用synchronized关键字可以解决原子性问题。



## 7、volatile是如何保证可见性、原子性的？

​	**通过内存读写屏障来保证可见性、原子性**。使用volatile修饰的变量，在读取操作时会在读取指令之前加上读屏障，读屏障保证：读屏障会从内存读取数据，所以使用volatile的变量能够保证可见性，并且保证在读屏障之后的指令重排序到屏障之前；在写操纵时，会在写操作指令之后加上写屏障，写屏障保证写屏障之前的指令不能重排序到写屏障之后，并且保证在写屏障之前的对共享变量的改动，都同步到内存中。



## 8、内存屏障如何实现？

​	通过插入特定的内存屏障指令来实现内存屏障。



## 9、JMM是什么？

​	JMM，java memory model，在不同硬件生产商和不同操作系统下，内存的访问操作有一定的差异，可能会造成相同的代码运行在不同的系统上会出现各种问题。java内存模型屏蔽掉各种硬件和操作系统的内存访问差异，以实现java程序在各种平台下都能达到一致的并发效果。



## 10、什么是happens-before原则？

​	happens-before原则表示的是前一个操作的结果对于后续操作的结果是可见的。可以认为在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作必须要存在happens-before关系。这两个操作可以是同一个线程，也可以是不同的线程。比如代码中前面的指令和后面的指令就满足这种关系。



## 11、什么是AQS？

​	全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架 。也就是jdk中定义好的一个同步器模板，通过这个模板，开发人员可以很方便的实现自己需要的同步器。



## 12、并发死链问题是什么？如何解决？

​	在jdk7中，HashMap在多线程并发环境下进行扩容时，可能会出现死循环的情况，这种情况叫做并发死链问题。具体来说，jdk7中造成死链问题的主要原因是扩容后的哈希表加入节点的顺序是将新的节点插入到链表的头部，这样会造成死循环问题。出现死链主要原因还是在并发场景下使用了非线程安全的Map集合。



## 13、Synchronized和ReEntryLock的区别是什么？

​	synchronized：

* 是java的关键字，自动获取和释放锁。
* 同步代码块中出现异常时，由jvm处理并释放锁。
* 阻塞式获取锁。
* 可重入、不可中断、非公平。



​	reentrylock：

* 是一个类，必须手动获取和释放锁。
* 出现异常时，必须使用try语句抓捕异常，在finally中进行锁的释放。
* 使用tryLock()可以尝试获取锁，一定时间内没有获取到，则放弃获取锁。
* 可重入、可中断、可公平。



## 14、如何解决缓存和数据库不一致问题？

​	**几种策略：**

* 更新数据库，也更新缓存

  ​	问题：两个更新是不同的操作，有可能出现并发写问题。如果有两个线程更新一个目标，假设线程A先更新了数据库，还没来得及更新缓存，这时候线程B也更新了数据库，同时更新了缓存，最后线程A才将缓存更新。按照理想的情况来说，最终数据库中的值是线程B更新的值，所以缓存中也应该是线程B更新的值，但最后缓存中的值却是线程A更新的值，出现脏读现象。

​	（补充一个图片更好理解）

* 删除缓存，更新数据库

  ​	问题：会出现并发读写问题。假设有一个写线程A和一个读线程B，在线程A删除缓存后，更新数据库之前，线程B要读取这个目标，先查询缓存，缓存未命中，从数据库中查找出来，并更新缓存，线程B执行完上述操作之后，线程A才更新数据库中的值，那么线程B此前读取出来的数据就是旧的数据，导致了脏读问题。

  ​	如何优化？使用双删策略，也就是在执行完删除缓存、更新性能数据库操作之后，延迟一段时间再删一遍缓存。（这个延迟时间的控制需要根据自己的业务调整）

  ​	如果采用了MySQL读写分离架构怎么办？在读写分离下，写线程对主数据库操作，读线程对从数据库操作，如果还是按照一般情况的双删策略制定延迟时间，则仍然会出现脏数据问题，因为第二次删除的时候，主服务器更新的数据还没有同步到从服务器上，所以延迟策略需要考虑上主从同步的时间，就可以解决脏数据问题了。

* 更新数据库，删除缓存

  ​	问题：会出现并发读写问题。假设线程A执行更新操作，线程B执行读操作。**情况一：**线程A更新完数据库，还没有更新缓存时，线程B执行读取操作，此时读到的数据是脏数据。**情况二：**线程B查询时缓存失效，则线程B需要读取数据库、更新缓存，这是两步操作，假设在线程B读取完数据库，更新缓存之前，线程A执行更新数据库，删除缓存操作，接着线程B才将刚刚读取到的数据写入缓存中，那么此后读取缓存的内容都是脏数据。

  ​	如何不让第二种情况出现？也是采取延迟双删策略。



​	选哪个策略？通常情况下，采用更新数据库，再删除缓存的策略，因为虽然此策略也会造成不一致的问题，但是两种不一致的情况中，第一种情况造成的影响有限，因为只有在线程A更新数据库和删除缓存之间进行读操作的线程才会出现脏读现象。第二种情况出现的概率很小，要基于两个时间同时发生：缓存失效、其他线程正在更新数据。

​	

​	**如果要强一致性呢？**无法保障，因为cap理论中一致性、高可用性、分区容错性无法同时满足，为了达到高可用的目的，就必须忍受不一致情况的发生，无法做到强一致性。



# JVM

## 1、为什么使用StringBuilder比字符串使用+拼接更加高效？

​	因为如果使用+进行拼接的话，编译成字节码的时候还是会创建StringBuilder进行字符串拼接，并且创建一个新的String对象作为返回，而且是每一次+的时候都会创建两个对象，而使用StringBuilder的话，只用创建一个StringBuilder对象和最终生成一个String对象返回。



## 2、新生代和老年代分别使用什么算法？为什么？

​	新生代：复制算法。因为复制算法的效率最高，但内存会有浪费，而新生代中进行垃圾收集是十分频繁的，所以选择效率最高的，内存使用有些浪费也是可以接受的。

​	老年代：标记压缩算法。



## 3、什么是热替换？如何实现？热替换中每次不重新new一个类加载器会怎么样？

​	热替换是指在应用程序运行过程中，动态的将类修改并且重新加载到JVM，实现运行过程中更新功能。

​	如果使用同一个类加载器，那么加载这个类的时候会先判断是否加载过，加载过的话就不会重新加载了，所以就不能进行热替换。



## 4、动态链接与静态链接？



## 5、什么是内存屏障？如何做到内存屏障？

​	我的理解：内存屏障是解决重排序问题的一种机制，至于什么是重排序呢？重排序包括三种：编译器重排序、CPU重排序、内存系统的重排序。重排序会造成什么问题？并发场景下，会造成可见性问题，导致程序运行的结果不在想要的结果之中。



## 6、什么是三色标记法？并发垃圾回收器使用三色标记法会出现什么问题？如何解决这些问题？







# Java的NIO

## 1、Channel究竟是什么，有什么用？

​	Channel是否就是封装了输入输出流的一个对象？它的内部是否就有缓冲？因为如果它的内部实现就是网络通信的话，应该会有一个缓冲区用来接收客户端发来的信息？



## 2、Buffer存在的意义是什么？

​	Buffer是不是就相当于一个缓冲的数组？只是为了面向对象的编程思想，把它专门抽象成了一个Buffer对象？我觉得是这样。



## 3、非阻塞IO是如何确定客户端传输来了数据的？

​	是否是为每个socket创建一个本地缓存，当从网卡上接收到发给这个socket的数据时，存到对应的缓存中，并且设置标识为待处理的socket？



## 4、读取一个Socket，究竟是从哪里读取的？是从网卡实时接收，还是先存到本地，再从本地读取？



## 5、什么是NIO？为什么NIO要比BIO效率高？



## 6、多路复用IO：select、poll、epoll有什么区别？

### select

原理：应用程序监听多个socket，每次调用select，都需要将当前监听的所有socket复制到内核态，由操作系统来查看是否有IO操作，当出现IO操作时，操作系统将这些socket做上标记，然后复制回内核态。在内核态中仍需要遍历全部的socket才能找出其中待处理的socket。

缺点：

* 每一次调用都需要将所有的socket传入内核态，并且返回给用户态，内核态和用户态处理的时候都需要遍历，在处理的socket很多时开销很大。
* 最多只支持1024个socket连接。
* 水平触发方式，如果一个socket用户处理时没有完全处理完，那么接下来的每次select调用都需要传递再次传递这个socket，直到处理完毕。

### poll

原理：和select基本一致，只是每次传递给内核时不再使用数组，而是使用链表，解决了最多只支持1024个socket的问题。

### epoll

原理：

​	调用时不再需要将socket数组传递到内核态，而是在内核态维护一个红黑树，用于存放所有的socket，并且也不需要将所有的socket传递会用户态，而是在内核态维护一个就绪链表，使用回调机制，当某个socket上有IO时就会触发回调函数，将这个socket放入就绪队列中，只需要将这个就绪链表复制给用户态就可以了。epoll调用分成了三个系统调用，其中epoll_create()是创建红黑树和就绪链表，epoll_ctl()向内核态中的红黑树对象添加监听的socket，红黑树会对这些socket自动去重，epoll_wait()收集发生了IO的socket，也就是获得内核态返回的socket链表。

​	除此之外，epoll还有两种模式：LT模式和ET模式。

* LT模式：水平触发，某次epoll_wait()函数返回后，应用程序对就绪的socket操作时没有读取完数据（缓冲区大小不够等原因），那么应用程序调用epoll_wait()时，操作系统还会将没处理完的socket放入到就绪链表中。
* ET模式：边缘触发，调用epoll_wait()返回的socket只会返回一次，也就是说，类似于上面的那种情况时，下次调用epoll_wait()时，不会返回前面返回却没有处理完的socket，除非这个socket上又发生了新的IO事件。

		为什么使用ET模式？因为在LT模式下，如果有大量的不同socket上的IO事件需要处理，但很多socket上的IO都需要多次处理才能处理完，那么这些socket需要在接下来的每一次调用epoll_wait()时，都传递一遍到用户态中。这样就导致处理的效率不高。
		
		但说是这么说，实际上我还是感觉ET模式下只处理一次后续不再理会这种方式效率只是短暂的高，因为被忽视的socket上的内容你迟早都得处理，除非你做的处理是一次就将网络IO操作执行完毕。总的来说，各有各的好，看程序员怎么使用吧（可能）。



# 设计模式

## 1、策略模式和简单工厂模式有何区别？

执行权不同：

* 简单工厂模式是创建所需要的对象，将执行权交给客户端。

* 策略模式是将执行权给封装起来了，在类的内部执行方法，对外只暴露一个调用接口，将结果返回。

控制点不同：

* 简单工厂模式是在工厂类中编写创建对象的代码，也就是说如果有多个类，由工厂类来判断选择创建哪一个类。
* 策略模式则是将判断交给了客户端，由客户端来判断要使用哪个策略，所以本质上还是加重了客户端代码的复杂程度。



​	为了解决策略模式带来的弊端，同时利用策略模式的优点：不需要调用者参与过多的方法调用，只需要指定使用哪个策略，剩余的由策略对象来完成。可以将简单工厂模式和策略模式结合使用，使用简单工厂模式封装选择策略的判断方法，这样调用者就无需做大量判断。



## 2、如何理解依赖倒转原则？

​	面向接口编程？

​	依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象。

​	我的理解：当我们在开发软件的时候，如果要设计两个相互依赖的模块，在这两个模块的抽象类中，应该要依赖另一个模块的抽象类，而不应该依赖具体的实现类，这样能够松耦合。



## 3、如何理解外观模式完美体现了依赖倒转原则和迪米特法则？

​	迪米特法则好说，客户端只依赖于外观类，而外观类再调用其他的类来实现相应的功能。但它怎么完美体现了依赖倒转原则？我的理解是这样：客户端依赖于外观类来实现具体的操作，相当于是依赖于抽象？因为这个外观类就是用来完成某一方法的，如果有一些细节需要改变，不会影响到客户端。



## 4、抽象工厂模式和工厂方法模式的区别？





## 5、适配器模式和代理模式的区别？适配器模式的思想是什么？

​	目的不同：适配器模式解决的问题是接口功能相似，但调用却不相同的情况。而代理模式一是不让原对象被直接调用，二是可以增强功能。

​	**大话设计模式中：**系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望服用一些现存的类，但是接口又与服用环境要求不一致的情况。




## 6、适配器模式的具体使用？





## 7、单例模式和静态工具类的区别？

​	如何理解大话设计模式中：实用类不保存状态，仅提供一些静态方法或静态属性让你使用，而单例模式是有状态的？
​	因为单例模式是用于创建对象的，创建的对象就有自己的状态，在不同的时刻状态可能发生改变，而静态类没有这样的特征。




## 8、设计模式原则有哪些？

​	单一职责原则、开闭原则、依赖倒转原则、里式替换原则、迪米特法则



## 9、装饰模式和代理模式有什么区别？

​	这两个模式确实在使用上是非常相似的，都是可以对原有类的功能进行扩展。但两个模式最大的区别我觉得就是代理模式一般是用于**对访问进行控制**，一般情况下，我们不能直接访问原有类，所以需要使用代理类来进行操作，进行功能的增强和访问控制。





# MySQL

## 1、聚集索引是什么？

​	MySQL低层存储数据的结构就是一个聚簇索引，将索引和数据结合在一起。



## 2、MySQL数据库插入数据时究竟是如何插入的？

​	得要根据具体的存储引擎来判断如何插入数据，如果是innodb存储引擎，则是先向聚簇索引中插入新数据，然后再向其他二级索引中插入新数据。



## 3、character_set_connection的作用是什么？

​	在已经有character_set_client和character_set_results来分别接收和响应客户端请求的情况下，character_set_connection的作用是什么？为什么不能直接从character_set_client转为内部操作字符集？



## 4、MySQL中的一页（数据页）是物理内存页吗？

​	MySQL中的一页大小是16kb，不知道现在的操作系统物理内存一页大小是多少。

​	应该不是物理内存页，物理内存页的大小应该是4kb（和操作系统有关吧）。



## 5、MySQL的数据是如何存储的？

​	为什么尚硅谷视频中，在116集中说，如果表中的数据都在一个数据页中，不按照主键查询时，就要顺序遍历单链表？并且老师还说想找到很大的连续内存是很难的，所以要使用单链表的形式组织数据。

​	难道是数据页中存储的并不是原始数据，而是数据的一些信息？每一行的一些信息，使用时还要再去读取磁盘，那不是太麻烦了？

​	MySQL使用innodb存储引擎时，使用的是聚簇索引来存储数据，真实的数据存储在叶子节点上。



## 6、为什么二级索引的非叶子节点上也要存储主键值？

​	是为了确保二级索引非叶子节点中目录项的唯一性，因为二级索引可能不是具有唯一性的，所以可能造成很多二级索引的列值是相同的，导致插入的时候不知道应该插入到哪个节点上，所以我们需要加上主键值以区分目录项，当目录项相同时，按照主键值大小来进行排序，这样的话，插入操作就会顺利很多。



## 7、最左前缀原则是什么？

​	在使用联合索引时，如果查询的条件不包含创建索引时最左边的列，即使你的查询条件包含了联合索引剩下的所有列，也用不上这个联合索引。



## 8、为什么创建存储函数时会报错？该怎么解决？

​	这是因为数据库开启了慢查询日志bin-log，主从复制中，主机会将写操作记录在bin-log中。从机读取bin-log日志，执行语句来同步数据。如果使用函数来操作数据，可能会导致从机和主机的数据不一致（个人理解），导致从机和主机操作时间不一致（不是很理解这个），所以为了保证一致性，MySQL默认不开启创建函数设置。

​	执行 set global log_bin_trust_function_creators=1; 语句解决问题。



## 9、浮点数和定点数有哪些区别？什么时候使用浮点数？什么时候使用定点数？

​	区别：

* **存储格式不同： **浮点数存储时会有精度缺失，因为其低层是以二进制数值形式存储的（应该是IEEE754标准）；而定点数不会产生精度缺失，因为定点数在MySQL中是以字符串形式进行存储的。
* **存储空间不同：**浮点数float和double类型都有固定的存储大小，float占用4字节，double占用8字节；定点数存储大小由精度M和标度D决定所占用字节为M+2，不是固定的。

		浮点数相对于定点数的优点是：在同样的存储空间下，浮点数所表示的数值范围要大于定点数。适用于取值范围大，又可以容忍微小误差的场景，比如科学计算场景（允许误差的情况下）。
		
		定点数相对于浮点数的优点是：精确度高，因为是使用字符串进行存储的，能够保证数据的精确性，适合于对精度要求极高的场景，比如涉及金额计算的场景。



## 10、TIMESTAMP类型和DATETIME类型有什么不同？该如何选择这两种类型？

​	区别：

* timestamp存储空间比较小，表示的日期时间范围也比较小
* 低层存储方式不同，timestamp低层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值，相当于java中System.currentTimeMillis()方法返回值。datetime低层存储的也是整型数值，但不是毫秒值（不确定）。
* 两个日期比较大小或日期计算时，timestamp更方便、更快。
* timestamp和时区有关。timestamp会根据用户的时区不同，显示不同的结果。而datetime则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。



​	开发中使用最多的时间类型就是datetime，因为这个数据类型包括了完整的日期和时间信息，取值范围更大，使用起来比较方便。

​	一般存注册时间、商品发布时间等，不建议使用datetime存储，而是使用时间戳timestamp，因为datetime虽然直观，但不便于计算。



## 11、为什么Innodb存储引擎中建议使用varchar类型？

​	课件中说的是innodb数据表中的行存储格式并没有区分固定长度和可变长度列，所有数据行都使用指向数据列值的头指针。这里我不太理解，复习到行格式的时候再看看。



## 12、什么是数据字典？

​	Innodb中用于存储一些元数据的内部系统表，这些表也被称为数据字典。



## 13、改变表的存储引擎，会造成什么影响？

​	如果一张表刚开始使用的存储引擎是innodb，在存储了一些数据之后，我把存储引擎改成了myisam存储引擎，那么低层存储数据的文件会不会改变？

​	经过我的测试之后发现：底层的存储文件会被改变。

​	在MySQL5.7版本下实验的结果（修改存储引擎之前）：

![image-20221113222334829](D:\文档\学习笔记\学习疑问.assets\image-20221113222334829.png)

​	修改之后：

![image-20221113222418632](D:\文档\学习笔记\学习疑问.assets\image-20221113222418632.png)



## 14、采用自增主键和随机主键对性能的影响有多大？





## 15、目录项是怎样建立的？

​	是只有数据页建立的时候分组建立目录项，还是包括索引页在内，都是分组建立目录项？

​	应该是都分组建立目录项，分组的原因是减少冗余，提高磁盘利用空间，进而提高查询效率，建立目录页的时候也可以使用分组的形式减少冗余，这是完全可行的。



## 16、对比哈希索引和B+树索引，说明为什么innodb不使用哈希索引？

​	哈希索引进行等值查询的效率非常高，在没有大量重复索引值的情况下，能够达到O(1)级别，是B+树索引无法企及的。

​	但哈希索引的一些缺点导致数据库索引一般不会采用哈希索引：

* 哈希索引无法适应范围查询，进行范围查询的时候，时间复杂度会退化为O(n)级别。而B+树的树形结构，包括它叶子结点的链表设计，都使得它在进行范围查询的时候依旧高效，保持O(log2n)的时间复杂度。
* 哈希索引的存储是没有顺序的，在进行Order by排序的时候，哈希索引还要对数据进行排序。
* 对于联合索引，hash值是将联合索引键值合并后计算的，无法对单独的一个键或者几个索引键进行查询。
* 对于等值查询来说，通常hash索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到哈希冲突的时候，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。
* 哈希索引不支持模糊查询，因为是将数据通过哈希算法计算出hash值后，再映射到哈希表中。



## 17、对比B树和B+树，说说两者的不同之处，为什么B+树更适合文件索引系统？

不同之处：

* B+树有k个孩子的几点就有k个关键字，而B树是孩子节点的数量=关键字+1。
* B+树中非叶子节点的关键字也会同时存在于子节点中，并且是子节点中最大或最小的关键字。而B树中子节点没有父节点的关键字。
* B+树中非叶子节点仅用于索引，不用于存储数据，跟记录有关的信息放在叶子结点中。而B树中，非叶子节点即用于索引，也保存数据。
* 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小顺序链接。



为什么B+树更适合文件索引系统？主要原因是**B+树的中间节点不存储数据。**

* B+树查询效率更稳定，所有的数据都在叶子节点上，每次查询都要找到叶子节点。
* B+树查询效率更高，因为通常B+树比B树更矮胖。同样的磁盘页大小，由于B+树中间节点不存储数据，所以它的中间节点能够存储更多关键字，也就有更多子节点，就更加矮胖。
* 在查询范围上，B+树的效率也比B树高。因为B+树所有的关键字都出现在B+树的叶子节点中，叶子节点之间又有指针相连，数据也是有顺序的，这使得范围查找可以通过指针连接查找。而B树中，由于某些数据可能不在叶子节点上，在中间节点上，进行范围查询的时候需要使用中序遍历才能完成范围的查找，效率要低得多。



## 18、Innodb存储引擎中为什么在页的基础上还要提出区、段、表空间的概念？

​	**为什么要有区：**因为在范围查询的时候可能会遍历到相邻的页，如果两个页在物理磁盘上的位置是随机的话，就会造成随机IO，导致效率很低。为了防止这种随机IO现象，使用区的概念，一个区就是在物理位置上连续的64个页，占用大小是1MB，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，虽然可能造成一些空间的浪费，但是消除了很多随机IO。

​	**为什么要有段：**对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，如果不区分叶子节点和非叶子节点的话，一个区的大小是有限的，就造成可能这个区装了很多非叶子节点，导致范围查询还是要进行随机IO（我的想法）。所以Innodb对B+树的叶子节点和非叶子节点进行了区别对待，分为叶子节点区和非叶子节点区。存放叶子节点区的集合就算是一个叶子节点段，反之称为非叶子节点段。



## 19、Innodb如何解决这种情况：刷新文件到磁盘时，文件刷新到一半时，服务器突然断电了。

​	通过判断页的文件头和文件尾中的checksum来判断当前页的刷新是否出了问题，如果是上述情况，则文件头和尾的checksum结果不相同，需要进行重新传输或者特殊处理。



## 20、什么是碎片区？为什么要有碎片区？

​	碎片区是用于存储不同类型的页的一块区，其中可以存储数据页、索引页等，而一般的区都是专门存储某一类型的页。

​	以完整的区为单位分配给某个段对于数据量较小的表来说太浪费存储空间了，因为一个区的大小是1MB，如果直接就以区为单位分配，那么再小的表也需要最少2MB空间，一个叶子节点段和一个非叶子节点段。为了避免这种情况，提出了先以碎片区存储某个段的页面，当某个段的页面数量达到32个碎片区页面后，再单独分配一个区给这个段。



## 21、什么时候子查询能够转换成连接查询？连接查询和子查询哪种方式更加高效，为什么？

​	第一个问题问的很宽泛，其实提出的不是很好。我觉得如果子查询是不同的表数据，那么就可以采用连接查询的方式替代子查询。

​	子查询的效率不高，因为

​	①执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询从临时表中查询记录。

​	②子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，索引查询性能会收到一定的影响。（join会产生临时表吗？如果会的话join是不是也有这个缺点？为搞清楚这点，我提出了第25个问题）。

​	③对于返回结果集比较大的子查询，其对查询性能的影响也就越大。



## 22、为什么带有IN的子查询会是相关子查询？

​	比如：

```mysql
select * from s1 where key1 in (select key1 from s2 where key1 = 'a')
```

​	因为这个SQL语句会被优化器优化成exist形式的SQL查询，将当前s1每条记录的key1传入到第二个子查询中，就变成了相关子查询了（大概是这样吧）。



## 23、什么是覆盖索引？

​	在使用二级索引查询时，如果要查询出来的所有字段都在当前索引中存在，比如：

~~~mysql
#key1上有一个普通索引
select key1 from s1 where key1 = 'a'
~~~

​	这样不需要回表操作的查询，这样的操作就称为覆盖索引。



## 24、为什么表连接的时候要使用小表连接大表？

​	因为要使用小表做驱动表，在没有索引的情况下，MySQL会对驱动表做优化，不是每次单独取出一个记录来和被驱动表的所有记录进行匹配，这样的话就可能会进行大量重复的IO，例如当前的记录取出了被驱动表的所有记录一次，而下一个记录还要再全部取出来一遍，所以，MySQL使用一个缓存，一次读取多条驱动表中的记录，然后取出被驱动表的记录时，和缓存中的所有记录匹配一次，这样就减少了很多不必要的IO。因为缓存大小是有限的，所以驱动表越小，IO的次数就越少。



## 25、连接查询会产生临时表吗？

​	连接查询不会产生临时表，join连接的低层逻辑是取出驱动表的一条记录，如果没有索引的话，就取出被驱动表的所有记录进行on条件的匹配，然后再进行where条件的过滤，不是将两个表连接之后再进行where条件的过滤，在这个过程中，没有产生临时表。



## 26、什么是索引条件下推？

​	类似于这样一条SQL：

~~~mysql
#key1上建立了索引
select * from s1 where key1 > 'z' and key1 like '%a';
~~~

​	我们直观的会认为执行流程是这样的：先使用索引查询第一个条件，然后把所有满足第一个条件的叶子节点都进行回表操作，取出完整的一条数据，然后再比较第二个条件，选出最终的结果。

​	如果经过第一个条件过滤后还剩下1万条数据，而再经过第一条数据查询后还剩下100条数据，按照刚刚所想的流程来走，就可能造成1万次随机IO，性能不理想。

​	但我们可以发现，第二个条件经过第一个条件过滤后的索引中也是可以进行判断的，如果我们先经过第二个条件的判断，再进行回表操作的话，可能就只有100次随机IO，效率大幅提升。

​	索引条件下推的好处：一个查询语句的条件中，使用到了一个字段，在联合索引（一般情况下是联合索引）中有这个字段，但是这个字段使用 了模糊查询或其他情况导致索引中的这部分失效了，使用索引条件下推可以在回表之前进行一个过滤，减少回表的次数。



## 27、什么是幻读现象？

​	为什么尚硅谷老师讲的和之前学的不太一样，幻读是指读入了新增的记录？那么究竟哪个是真的？

​	我百度了一下，发现老杜讲的好像不对，应该是现在这个版本比较对。



## 28、union和union all有什么区别？为什么建议使用union all？

​	使用union时，会生成一个临时表，这个临时表是有union的表拼接而成，然后会对这个临时表进行操作，去除掉相同的行。而union all则不会对union后的数据进行去重。

​	因为union要对临时表进行操作，而临时表中无法使用索引，且生成和维护临时表也需要开销。所以建议使用union all。



## 29、同样是要写到磁盘上，为什么不直接修改数据库文件，而是写入到redo日志中？redo日志中都记录了什么内容？

​	写入到数据库文件中的缺点：

* 由于Innodb存储引擎存储数据是以页为单位来存储和读取的，也就是说，查询和修改后的刷盘操作，都是一次操作一个页，如果每次修改完要修改磁盘上的数据库文件的话，有可能只修改了一个页中很小的一部分，但是却要把整个页面都刷新回磁盘中，代价太高。
* 还是上面那条的原因，数据库以页为单位从磁盘中读取和存入数据，就可能造成很多的随机IO，导致效率非常低。

		如果是写入redo日志的话，就可以避免大量的随机IO，并且每次只要把事务的操作写入到redo日志中就行了。
		
		redo日志中记录的是对物理磁盘上数据进行的操作。



## 30、redo log 和bin log的区别是什么？

​	redo log跟bin log的区别是：redo log是存储引擎层产生的，而bin log是数据库层产生的。假设一个事务，对表做十万行记录的插入，在插入过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。



## 31、什么是mtr？怎么理解一个mtr可能包含一组redo日志？

​	MySQL把对底层页面中的一次原子访问的过程称为一个Mini-Transaction，简称mtr。

​	一个mtr有可能对低层的页面进行多个操作，比如插入记录时如果没有按照主键递增的顺序进行插入，此时的插入操作造成了低层B+树的页分裂等操作，这时候就会有多个redo记录下这些操作，所以说一个mtr可能包含一组redo日志。



## 32、为什么undo log也会产生redo log？

​	因为将操作写入undo log的过程中也需要保障一致性，所以需要将修改undo log的操作也先记录进redo log中。

​	再次提问：为了保障事务的一致性，由于更新数据库的操作可能会造成随机IO，所以先写入redo log可以理解，但写入undo log不是和redo log一样，很少随机IO吗，那为什么undo log也会产生redo log？

​	并不是如此，之前我一直以为写入undo log中和写入redo log中是一样的，都是写入文件而已，但是undo log却是以回滚段和undo页的形式存在的



## 33、脏写、脏读、不可重复读、幻读现象分别是什么？

​	脏写：两个事务同时对一条记录进行修改，对方事务还没有提交，当前事务修改了这条记录并且提交了，而随后对方事务也进行了记录的修改并提交，且覆盖掉了前一条事务的修改，造成了这样一种现象：命名我操作的事务进行了修改，但却看不到我的修改。

​	脏读：对方事务还没有提交，当前事务就读到了被修改的数据，但随后对方事务可能进行回滚，所以当前事务读到的数据是脏数据，并不是实际的数据。

​	不可重复读：当前事务先读取了某一条记录，随后这条记录被别的事务修改并提交了（只有读未提交隔离级别下不用提交也可以造成），当前事务再一次读取同一条记录，读取到的结果却和第一次不同了，也就是说，在一个事务中，发生了读取数据不一致的行为。

​	幻读：当前事务对数据进行修改，随后其他事务对数据进行了插入操作，导致当前事务发现表中存在还未被修改的记录，就好像发生了幻觉一样。比如一个事务对一个表执行条件查询 select * from table where id = 3 ，随后另一个事务在这个表中插入了id为3的记录。



## 34、关于二级索引中进行操作产生的疑问

​	如果在一个事务插入了一条记录，然后造成了二级索引新加了一条记录，这时候另外一个事务对二级索引进行了查找，如果要查找这条记录，这时候MySQL是如何处理的？

​	每个二级索引的页面的页面头中都有记录一些信息，其中针对此情况起到作用的是PAGE_MAX_TRX_ID属性，该属性代表对该页面做改动的最大的事务id，所以第二个事务操作的时候需要检查二级索引页面中的这个属性，如果最近一次修改此页面的事务是已提交页面的话则可以进行操作，否则的话就去聚簇索引中查找这条记录所对应的行信息，再做一些校验。



## 35、在MVCC中如果一个事务进行delete操作，但还没有提交，那么别的事务来查询，是一个怎样的流程？

​	首先，事务中的删除操作并不是真正的删除掉了这条数据，而是将数据行格式的delete_bit设置为1，然后等待purge线程来进行回收，如果删除操作的事务还没有提交，那么这条记录是肯定不会被清除的，而未删除的版本也在undo日志中进行了记录。所以此时别的事务来查询，也是按照快照读的流程走，最终找到可以读的历史版本。



## 36、redo日志两阶段提交是什么？为什么要使用两阶段提交？

​	redo日志的两阶段提交是指为了保证redo日志和bin-log日志的一致性，在刷盘bin-log缓存的前后将redo日志的刷盘过程分为两步：prepare阶段和commit阶段。

​	使用两阶段提交是为了确保redo和bin-log中数据的一致性。



## 37、bin-log格式有何区别？

​	statement格式中就是记录所执行的一条SQL语句，而row格式记录的就是所影响的行信息。

​	比如update操作影响到了很多行的时候statement格式就只会记录这条update语句，而row格式就会记录具体哪些行做了哪些修改。

~~~MySQL
update class set monitor = 5 where id > 10;
~~~

​	在statement格式中就只会记录这一条SQL语句，而row格式中会记录下来所有被改变的行，假如此时class表中id > 10的数据有100条，那么这100条全部都会被记录下来。



## 38、进行全表扫描的update时，会将所扫描到的所有记录都锁定吗？

### read-committed隔离级别下	

​	在read-committed隔离级别下，我的测试结果如下，事务A：

![image-20221126150102844](.\学习疑问.assets\image-20221126150102844.png)

​	事务B：

![image-20221126150126581](.\学习疑问.assets\image-20221126150126581.png)

​	为什么事务B仍然查出来了，明明事务A使用的是全表扫描。

​	但如果事务B执行如下：

![image-20221126150519860](.\学习疑问.assets\image-20221126150519860.png)

​	则会进入等待中，这是什么原理？还是没搞清楚，以后再看看。



### repeatable-read隔离级别下

​	然而在repeatable-read隔离级别下，上面例子的两个操作都会阻塞住，说明for update确实是将扫描到的所有记录锁住了。

**另一种情况：**for update加锁的行使用了索引

​	事务A：

![image-20221126165135691](.\学习疑问.assets\image-20221126165135691.png)

​	事务B：

![image-20221126165209842](.\学习疑问.assets\image-20221126165209842.png)

​	可以看到，事务B并没有被阻塞，说明for update这次上的是行锁。

​	然而如果事务B按照非索引字段进行查询，则会进入阻塞：

![image-20221126165438447](.\学习疑问.assets\image-20221126165438447.png)

​	这是什么原因造成的呢？我的推测是for update和for share操作都会对遍历到的记录加锁，所以上一种情况下不使用索引的for update将所有扫描过的记录都锁住了。而这种情况值扫描了一个记录，所以只锁住了一条记录，当使用索引的for share时，找到别的记录就不会被阻塞了。而不使用索引的for share，也需要进行全表扫描，最终扫描到for update的那条记录，就会阻塞住。



**再一种情况：**

​	事务A：

![image-20221126171001049](.\学习疑问.assets\image-20221126171001049.png)

​	事务B：

![image-20221126171016243](.\学习疑问.assets\image-20221126171016243.png)

​	验证了索引覆盖的情况，第二次查询由于只需要id字段，所以直接在二级索引里查找并锁定二级索引就行了。



## 39、为什么undo只是逻辑上将数据库恢复到原来的样子？

​	undo日志记录的是逻辑上恢复的操作，比如事务中进行了insert，那么undo日志中记录的就是一条delete语句，但如果在插入数据的过程中进行了页分裂或其他改变底层聚簇索引的操作，使用undo回滚的时候并不会将物理结构修改回原来的样子。

​	为什么不进行物理的恢复：因为在多用户并发系统中，可能会有多个并发事务同时执行，如果多个事务同时对一个表中的不同记录进行修改，如果是将数据物理的恢复成事务之前的样子，当一个事务回滚的时候，改变了底层的物理结构，会影响到同时在进行操作的其他事务。



## 40、MySQL可重复读隔离级别是如何解决幻读问题的？彻底解决了幻读问题吗？

​	通过MVCC+临键锁的方式解决，临键锁锁住记录之间的间隙，防止别的事务进行插入，MVCC执行快照读，避免读取到与当前事务并发执行的事务插入的数据。

​	我认为是没有彻底解决幻读问题的，因为要完全避免幻读问题，就要将所有可能读到的间隙锁起来，这样的话造成锁太多，降低并发度。如果不在乎并发度的话，是可以解决幻读问题的。

​	

## 41、为什么交错锁模式从bin log重播SQL语句时是不安全的？

​	首先，交错锁模式是自增锁的一种模式，它有可能造成插入的行生成的值不是连续的。

​	然后，应该要从bin log日志恢复数据的角度来思考为什么是不安全的，有些忘了，先留个悬念。

**redo、undo、bin log记录的情况**：

* redo记录的是物理的操作，比如对磁盘上的哪个页进行了怎样的操作。
* undo记录的是逻辑的操作，比如插入一条记录，undo中记录的就是删除这条记录的操作，并不能物理的恢复。
* bin log记录的情况和其使用的格式是相关的，如果使用statement格式，则记录执行的语句，如果使用row格式，则记录的是对物理文件中某一行的操作。同时bin log记录语句是以事件的方式来进行记录的。bin log记录的也是逻辑的操作。



## 42、元数据锁有可能带来什么问题？

​	如果事务A对一张表进行了DML操作，获取了这张表的MDL（元数据锁）读锁，然后事务B要进行DDL操作，需要获取这张表的MDL写锁，此时就需要阻塞了，在这个时候，如果事务C要对这张表进行DML操作，也是要获取MDL读锁，正常情况下，应该是可以获得的，但是由于事务B被阻塞了，此时事务C也会被事务B阻塞。



## 43、数据页中固定的最大和最小记录有什么作用？

* 在给边界加间隙锁的时候，最大和最小记录就能够起到作用了，因为间隙锁是锁住小于当前记录的间隙，所以锁住最大记录就可以防止其他事务往边界情况插入记录，比如当前最大的主键值是20，锁住最大记录可以防止插入主键值大于20的记录。
* 便于插入和删除页中的记录，因为innodb的存储结构是一个B+树，存储记录的页面中使用链表的形式组织行记录，这时候最大最小记录就相当于链表中的头尾节点，在操作的时候方便很多。



## 44、什么是隐式锁？

​	我的理解是：隐式锁是指在一个事务中进行了添加记录操作，当前事务没有提交时，虽然添加的记录没有显式的添加锁结构，但是其他事务进行操作时都会通过检查隐藏字段trx_id来确保这个记录是可以操作的。

​	具体案例：事务A在表中添加了一条记录，事务A还没有提交，此时事务B要给这条记录加锁

* 对于聚簇索引记录操作，事务B检查记录行的trx_id，如果是活跃的事务，那么给这条记录加上事务A的锁，然后再生成自己的锁，进入等待。
* 对于二级索引记录操作，检查页Page Header的PAGE_MAX_TRX_ID属性，如果这个值小于当前活跃事务的最小id，那么可以操作，否则，回表然后进行和上面一样的操作。



## 45、为什么一个事务查询数据时给数据加了排它锁，但是其他事务依然能够读取到这些数据？

​	事务A：

~~~mysql
begin;
select * from class for update;
~~~

​	事务B：

~~~mysql
begin;
select * from class;
~~~

​	因为事务B只是简单的读取数据，并没有给数据加锁。

如果事务B：

~~~mysql
begin;
select * from class for share;
~~~

则会阻塞



## 46、事务是怎样对于记录加锁的？是每锁一条记录就生成一个锁结构吗？

​	对于符合一定条件的记录，会使用同一个锁结构，具体满足以下条件：

* 在同一个事务中进行的加锁操作
* 被加锁的记录在同一个页面中
* 加锁的类型是一样的
* 等待状态是一样的



## 47、索引在什么情况下会失效？

* 查询条件中使用了计算、函数、类型转换都会导致索引失效，其中类型转换不管是手动的还是自动的，都会失效。
* 当查询条件中有范围查询时，如果是范围查询的列是联合索引中的一部分，那么即使在查询的右边还有联合索引的列，并且满足最左前缀原则，也不会使用到。
  * 比如：select * from test where id > 1 and age = 20，即使联合索引是(id,age)，此时索引只会用上联合索引的前面部分，即id部分，而用不上age。
* 查询条件中使用了不等于时，索引也会失效。为何？因为不等于的范围很广，查询优化器直接判定不如直接全表扫描。
* 查询条件中使用了is not null。类似于不等于条件。
* 查询条件中使用like，并且模糊查询以%开头，此时索引会失效。
* 查询条件中的or前后存在非索引的字段（列），索引失效。
* 数据库和表的字符集最好是统一使用utf8mb4，要不然可能会由于字符转化造成索引失效



## 48、数据库如何进行调优？

### 1、优化服务器硬件

​	服务器硬件性能直接决定这MySQL数据库的性能。

### 2、优化MySQL的参数

​	innodb_buffer_pool_size表示innodb引擎的表和索引的最大缓存；key_buffer_size表示索引缓冲区的大小；table_cache表示同时打开的表的个数；innodb_log_buffer_size表示事物日志所使用的的缓冲区。

### 3、优化数据库的结构

* **拆分表**，将冷热数据分离，比如将用户信息中不常用的数据拆分出来，放入用户详情表中。这种分解可以提高表的查询效率，对于字段很多且有些字段不常用的表，可以通过这种分解方式来优化数据库性能。
* **增加中间表**，比如有学生和班级表，班级表中有每个班级对应的班长信息，现在有一个业务要经常使用学生、班级、班长信息，可以考虑创建一个中间表，专门存放着三个信息。
* **增加冗余字段**，比如学生和班级信息是分开存放的，但是业务现在的需求是频繁的查询学生和对应的班级名称，那么我们可以在学生表中添加上班级名称这个冗余字段。
* **优化数据类型**，整数数据类型可以使用int，在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率，对于非负型整数，优先使用unsigned存储，因为unsigned有更大的存储空间。优先使用整数类型，对于既可以使用文本类型又可以使用整数类型的情况下，使用整数可以占用更少的存储空间，例如存储IP地址，既可以使用使用字符串，也可以使用整型。
* **优化插入记录的速度**，Innodb引擎的表可以：禁用唯一性检查、禁用外检检查、禁止自动提交；MyISAM引擎的表：禁用索引、禁用唯一性检查、使用批量插入。
* **使用非空约束**，在设计字段的时候，如果业务允许，建议尽量使用非空约束，首先如果允许存在null值，那么在innodb的行格式中就要多出一个null值列表，多占用一些存储空间。其次，在查询的时候如果可以为null，那么还要全部过滤一遍，索引效率高的前提是列的区分度大，包含`NULL`的列很难优化，而且对表索引时不会存储 `NULL` 值。如果索引字段可以为 `NULL`，索引的效率会下降。因为它们使得索引、索引的统计信息以及比较运算更加复杂，所以要求列值非空。
* **分析、检查、优化表**，MySQL中提供了analyze table语句分析表，使用analyze table分析表时，数据库系统会自动为表加一个只读锁；MySQL中可以使用check table语句来检查表，该语句能够检查innodb和MyISAM类型的表是否存在错误，使用过程中也会为表加上只读锁。MySQL中使用optimize table语句优化表，但只能优化varchar、blob、text类型，使用过程中也会给表加上只读锁。

注意：上述的这些方法都是有利有弊的，比如，修改数据类型可以节省空间，但同时你需要考虑是否会超出这个类型的存储范围，否则如果超出了范围，会造成严重的后果；增加冗余字段需要格外注意数据一致性；把大表拆分，意味着你的查询会增加连接操作，带来额外的开销和运维成本。



### 4、大表的优化

#### 限定查询范围

​	禁止任何不带任何限制数据范围条件的查询语句。比如在查询历史订单的时候，我们可以控制在一个月的范围内。

#### 读写分离

​	主库负责写，从库负责读。主要有一主一从模式、双主双从模式等。

#### 垂直拆分

​	当数据量级达到千万级以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。垂直拆分的优点是可以使列数据变小，在查询时减少读取Block数，减少IO次数。此外，垂直分区可以简化表的结构，易于维护。缺点是主键会出现冗余，需要管理冗余列，并会引起JOIN操作。此外，垂直拆分会让事务变得更加复杂。

#### 水平拆分

​	数据库分片的两种方案：客户端代理，分片逻辑在应用端，封装在jar包，通过修改或者封装JDBC实现，当当网的Sharding-JDBC、阿里的TDDL是两种比较常用的实现。中间件代理，在应用和数据中间加了一个代理层，分片逻辑统一维护在中间件服务中，我们现在谈得Mycat，360的Atlas，网易得到DDB等等都是这种架构的实现。



### 5、其他调优策略

#### 服务器语句超时处理

​	在MySQL8.0中可以设置服务器语句超时的限制，单位可以达到毫秒级别。当中断的执行语句超过设置的毫秒数后，服务器将终止查询影响不大的事务或连接，然后将错误报告给客户端。可以通过设置系统变量MAX_EXECUTION_TIME来设置超时限制。

#### 创建全局通用表空间

#### 隐藏索引来进行调优






## 49、MySQL的undo日志记录的究竟是什么？如果记录的是还原sql，那么mvcc是如何使用undo日志做到快照读的？
  我的想法：undo日志中记录的不是还原sql，而是记录了更新之前的列属性，所以可以通过这个来还原数据，也可以通过这个来实现mvcc的快照读。