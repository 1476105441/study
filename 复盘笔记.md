# 2023

## 4月

### 2023/4/16复盘

昨日学习：go语言基础语法、算法题（不认真）

1、go语言的命名：包级别的变量命名规则是首字母大写能够在包外使用，小写则不能。

2、声明：声明的类型有四种（var、const、type、func），变量声明方式有多种（var 变量名 变量类型、变量名 := 值、var 变量名 变量类型 = 值、var 变量名 = 值）。

3、赋值：赋值形式也有多种，其中普通赋值就像其他语言中使用的一样；元组赋值是我接触的独特的赋值方式，可以同时给多个变量进行赋值，像交换值的操作就可以很方便的完成。

4、类型：通过声明类型可以自定义类型，不同类型之间虽然低层的结构可能是相同的，但是使用时不能够混着使用，用来分隔不同的概念。类型声明一般在包级别进行声明。同时声明函数时在函数名之前用括号表名所属的类型，就能够表示当前函数是属于某个类型的，就可以通过这个类型的变量来调用（类似于java的实例方法）。例如下面的String函数声明，同时需要明白，改写了String方法后，使用标准输出时默认调用String方法，就和java的toString方法一样。

~~~go
func (c Type) String() string { return "改进了一个类型的String方法" }
~~~

5、包：通常一个包所在目录路径的后缀是包的导入路径；例如包gopl.io/ch1/helloworld（导入路径）对应的目录路径是$GOPATH/src/gopl.io/ch1/helloworld。包的名字一般和导入路径中的最后一个字段相同。同一个目录路径下的多个.go源文件可以属于同一个包。导入语句会将包绑定到一个短小的名字，然后通过名字就可以引用包中的内容。包的初始化机制是另一个重要的点，首先是包级变量的初始化，如果变量之间有依赖，会先初始化没有依赖的变量，然后往上逐个初始化。如果一个包有多个源文件，将按照发给编译器的顺序初始化，go语言构建工具首先会将.go文件根据文件名排序，然后依次调用编译器。可以使用init函数初始化包级变量。每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。

6、算法题：使子数组元素和相等。

问题：

1、包的导入时如果发生了循环依赖该如何解决？



### 2023/4/20复盘

1、utf-8的优点：编码紧凑、完全兼容ASCII、可以自动同步；它是前缀编码，从左往右解码时不会有任何歧义；没有任何字符的编码是其他字符编码的子串，因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心上下文会对搜索结果产生干扰。



### 2023/4/21复盘

1、go语言常量：编译期计算，值不能发生修改；iota常量生成器，使用iota声明一组常量，能够自动为常量赋上值。

2、算法题：图中的最短环，一开始的想法是对每个节点开始深度优先遍历并且遍历过的节点进行标记，但忽略了部分相同的节点构成两个环的情况。使用遍历+bfs解决此问题。计算路径是一个难点。



### 2023/4/22复盘

1、go语言：数组的长度是固定的，因此go语言中较少使用数组。

2、声明数组的方式和其他语言差别有点大：var arr [3]int = [3]int{1,2,3}。

3、长度也是go语言数组类型的一部分，因此不同长度的相同元素类型的数组也是不同类型的。

4、算法题：依然是图中的最短环，整体的思路是构建图模型，然后从每个节点开始进行bfs遍历，细节就在于bfs中。

5、mit6.824：学习了go语言的并发知识，和java中的并发非常相似。