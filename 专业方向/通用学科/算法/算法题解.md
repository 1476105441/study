# 动态规划

## 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

    '.' 匹配任意单个字符
    '*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

示例1：

~~~
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
~~~

示例2：

~~~
输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
~~~

提示：

    1 <= s.length <= 20
    1 <= p.length <= 30
    s 只包含从 a-z 的小写字母。
    p 只包含从 a-z 的小写字母，以及字符 . 和 *。
    保证每次出现字符 * 时，前面都匹配到有效的字符



**解题思路**：

​	此题目明显可以使用动态规划来求解，关键在于如何进行状态转移？

​	正确的思维是从后往前来看待状态转移方程



# 数组和字符串



## 删除无效括号

### 第三种解法：枚举状态子集



**解题思路：**统计字符串中要删除的左括号数和右括号数，然后对左括号进行删除，将所有删除的情况都列出来，对右括号也是如此，然后将左括号删除的情况和右括号删除的情况进行组合，检查哪种组合是合法的，使用哈希表进行去重，最终就得到了答案。



**算法实现:**

由于每种删除的集合很难表示，方法传递时若是传递一个删除下标集合的话就会很麻烦，本题的算法实现使用二进制位来表示要删除的情况，比如1，2，4等二的倍数在二进制表示时只有一个二进制位为1，则代表删除对应位上的元素，比如：1的二进制表示是第一个二进制位为1，其余都为0，则1表示删除第一个元素；2的二进制表示是第二个二进制位为1，其余都为零，表示删除第二个元素，以此类推。那么当数字不是二的倍数的时候，可以表示删除多个元素，比如3，它的二进制位是第一和第二个二进制位为1，其余位 为0，表示删除第一个元素和第二个元素，删除两个元素，二进制位有多少个1就代表要删除多少个元素

``` java
public List<String> removeInvalidParentheses(String s) {
        int lremove = 0;
        int rremove = 0;
        //left和right存储的是字符串中对应左括号和右括号的下标
        List<Integer> left = new ArrayList<>();
        List<Integer> right = new ArrayList<>();
        List<String> ans = new ArrayList<>();
        Set<String> cnt = new HashSet<>();

        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                left.add(i);
                lremove++;
            } else if (s.charAt(i) == ')') {
                right.add(i);
                if (lremove == 0) {
                    rremove++;
                } else {
                    lremove--;
                }
            }
        }

        int m = left.size();
        int n = right.size();
        List<Integer> maskArr1 = new ArrayList<Integer>();
        List<Integer> maskArr2 = new ArrayList<Integer>();
        for (int i = 0; i < (1 << m); i++) {
            if (Integer.bitCount(i) != lremove) {
                continue;
            }
            maskArr1.add(i);
        }
        for (int i = 0; i < (1 << n); i++) {
            if (Integer.bitCount(i) != rremove) {
                continue;
            }
            maskArr2.add(i);
        }
        for (int mask1 : maskArr1) {
            for (int mask2 : maskArr2) {
                if (checkValid(s, mask1, left, mask2, right)) {
                    cnt.add(recoverStr(s, mask1, left, mask2, right));
                }
            }
        }
        for (String v : cnt) {
            ans.add(v);
        }

        return ans;
    }

    //检查合法性
    private boolean checkValid(String str, int lmask, List<Integer> left, int rmask, List<Integer> right) {
        //pos1用于定位左括号集合
        int pos1 = 0;
        int pos2 = 0;
        int cnt = 0;

        for (int i = 0; i < str.length(); i++) {
            if (pos1 < left.size() && i == left.get(pos1)) {
                if ((lmask & (1 << pos1)) == 0) {
                    cnt++;
                }
                pos1++;
            } else if (pos2 < right.size() && i == right.get(pos2)) {
                if ((rmask & (1 << pos2)) == 0) {
                    cnt--;
                    if (cnt < 0) {
                        return false;
                    }
                }
                pos2++;
            }
        }

        return cnt == 0;
    }

    //恢复字符串？
    private String recoverStr(String str, int lmask, List<Integer> left, int rmask, List<Integer> right) {
        StringBuilder sb = new StringBuilder();
        int pos1 = 0;
        int pos2 = 0;

        for (int i = 0; i < str.length(); i++) {
            if (pos1 < left.size() && i == left.get(pos1)) {
                if ((lmask & (1 << pos1)) == 0) {
                    sb.append(str.charAt(i));
                }
                pos1++;
            } else if (pos2 < right.size() && i == right.get(pos2)) {
                if ((rmask & (1 << pos2)) == 0) {
                    sb.append(str.charAt(i));
                }
                pos2++;
            } else {
                sb.append(str.charAt(i));
            }
        }

        return sb.toString();
    }
```



***



## 滑动窗口的最大值



### 解法一：优先队列

**解题思路**：滑动窗口移动时动态的维护一个最大堆（优先队列），每次从最大堆中取出堆顶，检查是否是滑动窗口内的元素，即元素下标值是否大于滑动窗口的左边界，如果不是当前滑动窗口内的元素，则将堆顶元素移除，如果是当前窗口内的元素，则放入结果集中。

~~~java
//来自官方题解给出的答案，我自己写的堆排序优先队列会超时
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });
        for (int i = 0; i < k; ++i) {
            pq.offer(new int[]{nums[i], i});
        }
        int[] ans = new int[n - k + 1];
        ans[0] = pq.peek()[0];
        for (int i = k; i < n; ++i) {
            pq.offer(new int[]{nums[i], i});
            while (pq.peek()[1] <= i - k) {
                pq.poll();
            }
            ans[i - k + 1] = pq.peek()[0];
        }
        return ans;
    }
}
~~~



Java自带的优先队列调整函数：

![1650251860132](D:\wjs\Documents\算法\算法题解.assets\1650251860132.png)

Java自带的优先队列加入函数：

![1650254803833](D:\wjs\Documents\算法\算法题解.assets\1650254803833.png)

**观看了源码之后自己写的优先队列解法**：

~~~java
//看了源码之后写第一种解法：
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length,left = 0,right = k-1,length = k;
        int[][] temp = new int[n][2];
        int[] res = new int[n-k+1];

        //先调整第一个滑动窗口的值
        for (int i = 0; i < k; i++) {
            temp[i][0] = nums[i];
            temp[i][1] = i;
        }
        merge(temp,k);
        res[0] = temp[0][0];
        right++;
        left++;
        while (right < n) {
            temp[length][0] = nums[right];
            temp[length][1] = right;
            shiftUp(temp,length);
            length++;
            while (temp[0][1] < left) {
                temp[0][0] = temp[length-1][0];
                temp[0][1] = temp[length-1][1];
                length--;
                shiftDown(temp,length);
            }
            res[right-k+1] = temp[0][0];
            right++;
            left++;
        }

        return res;
    }

    //移除堆顶元素调用的调整函数
    public void shiftDown(int[][] nums,int n){
        //half是第一个叶子结点的下标，注意n是移除堆顶之后的长度
        int half = n >>> 1,i = 0;
        int[] temp = nums[i];

        while (i < half) {
            int j = (i << 1) + 1;
            if (j + 1 < n && nums[j][0] < nums[j + 1][0]) {
                j++;
            }
            if (temp[0] > nums[j][0]) {
                break;
            }
            nums[i] = nums[j];
            i = j;
        }

        nums[i] = temp;
    }

    //加入新元素调用的调整函数，n是加入之前的长度
    public void shiftUp(int[][] nums,int n){
        //temp就是新加入的元素
        int[] temp = nums[n];
        while (n > 0) {
            //和他的父节点比较，第一个非叶子节点就是新加入元素的父节点
            int parent = (n-1)>>>1;
            if (temp[0] < nums[parent][0]) {
                break;
            }
            //把父节点移下去
            nums[n] = nums[parent];
            n = parent;
        }
        nums[n] = temp;
    }

    public void shift(int[][] nums,int n,int begin){
        int i = begin ,j = 2 * i + 1;
        while (j < n) {
            if (j < n - 1 && nums[j + 1][0] > nums[j][0]) {
                j++;
            }
            if (nums[i][0] < nums[j][0]) {
                int[] temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i = j;
                j = 2 * i + 1;
            }else
                break;
        }
    }

    public void merge(int[][] nums,int n){
        int i = (n-2)/2;
        for (; i >= 0; i--) {
            shift(nums,n,i);
        }
    }
~~~





### 解法二：双向队列（单调队列）

**解题思路：**观察滑动窗口特点，向右滑动，原数组中在左边的元素要先于右边的元素出队列，我们可以维护一个队列，存放滑动窗口中可能为最大值的元素，那么可以发现，在滑动窗口中，如果一个元素的右侧还有比它大的元素，那么该元素不可能是值最大的元素，因为在它后面的元素比它大，还比它晚出窗口，可以说这个元素是永无翻身之日，所以我们可以直接排除这样的元素；而对于右侧没有比其大但左侧有比其大的元素可以保留在这个队列中，因为它有可能熬到左侧比它大的元素出队列，那么它就成了最大的元素。所以我们要维护的一个滑动窗口中的队列其实是一个单调递减的队列，不允许出现递增的队列。还有一个要注意的点是要维护队列的更新，由于窗口的滑动而不在窗口中的元素要及时移出队列，所以可以利用数组使用下标检索效率非常高的特点，在队列中存储的是元素的下标。

~~~java
public int[] maxSlidingWindow(int[] nums,int k){
        Deque<Integer> queue = new LinkedList<>();
        int[] res = new int[nums.length-k+1];
        int right = k;

        //初始化单调队列
        for (int i = 0; i < k; i++) {
            while (!queue.isEmpty() && nums[i] >= nums[queue.getLast()]) {
                queue.pollLast();
            }
            queue.offerLast(i);
        }
        res[0] = nums[queue.getFirst()];

        while(right < nums.length) {
            while (!queue.isEmpty() && nums[right] >= nums[queue.getLast()]) {
                queue.pollLast();
            }
            queue.offerLast(right);
            if (queue.getFirst() < right - k + 1) {
                queue.pollFirst();
            }
            res[right-k+1] = nums[queue.getFirst()];
            right++;
        }

        return res;
    }
~~~





### 解法三：分块+动态规划

**解题思路：**前两种解法都是在滑动窗口滑动时动态的维护窗口中的信息，还有一种解法是静态的计算数组中的信息以满足滑动窗口的需要将每k个元素划分为一组，最后一组可能不足k个，不过没有关系，然后在窗口滑动时，如果起始位置是k的倍数，则是一个组的起始位置，当前滑动窗口刚好与一组重合，若是提前计算好一组的最大值，则可以直接得出结果，如果起始位置不是k的倍数，则当前滑动窗口必然会跨过两个组，我们只需要计算出前一个组中以i为起始的后缀的最大值，和后一个组中以i+k-1为结尾的前缀的最大值，比较这两个最大值即可得出当前窗口的最大值。所以我们要计算的其实就是两个值，在一个分组中以i为起始的后缀最大值和以i为结尾的前缀最大值。

~~~java
public int[] maxSlidingWindow(int[] nums,int k){
        int[] prefix = new int[nums.length],suffix = new int[nums.length];
        int sufIndex;
        int[] res = new int[nums.length-k+1];

        for (int i = 0; i < nums.length; i++) {
            if (i % k == 0) {
                prefix[i] = nums[i];
            }else
                prefix[i] = Math.max(prefix[i-1],nums[i]);

            sufIndex = nums.length-1-i;
            if ((sufIndex+1) % k == 0 || sufIndex == nums.length-1) {
                suffix[sufIndex] = nums[sufIndex];
            }else
                suffix[sufIndex] = Math.max(suffix[sufIndex+1],nums[sufIndex]);
        }

        for (int i = k-1; i < nums.length; i++) {
            int start = i-k+1;
            res[start] = Math.max(suffix[start],prefix[i]);
        }

        return res;
    }
~~~





***



## 最小覆盖子串

```
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

 注意：
     对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
     如果 s 中存在这样的子串，我们保证它是唯一的答案。
     
 提示：
     1 <= s.length, t.length <= 105
     s 和 t 由英文字母组成
     
 进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？
```

**解题思路：**拿到题目最直观的想法就是遍历s，统计在t中应该出现的元素个数，当个数满足时计算一次当前所用的长度，然后再往后找。在这个过程中需要注意，如果有多个相同的所需要的元素，直接从当前最后找到的所需元素往后遍历的话就会漏掉这些可能性，这些相同的元素可以替换在它之前的元素，所以我们应该维持当前最右边的元素不变，而改动最左边的元素，这样一看，这不就是一个滑动窗口吗。滑动窗口的滑动规则如下：统计所需的元素个数，这里用减法来区分是否集齐所需的所有元素，如果没有，就移动右指针来扩充窗口，寻找元素，如果元素是我们所需要的元素，那么经过判断区分这个字符是否已集齐，没集齐就让整体个数减一，集齐了就不用减，因为它没有对整体的构成做出贡献。当全部的所需元素集齐时，即所有需要的元素都包含在窗口中之后，我们就开始缩小窗口的范围，移动左指针来缩小，使得能够尽可能的获得最短的字符串。其中还有一些细节需要仔细体会。

~~~java
public String minWindow(String s,String t){
        int[] value = new int[60],need = new int[60];
        char[] sChar = s.toCharArray(),tChar = t.toCharArray();
        int left=0,start=-1,end=-1,min=-1,count=tChar.length;

        for (int i = 0; i < count; i++) {
            int loc = tChar[i] - 'A';
            value[loc]++;
            need[loc]++;
        }

        for (int i = 0; i < sChar.length; i++) {
            int loc = sChar[i] - 'A';
            if (value[loc] > 0) {
                count--;
            }
            value[loc]--;

            //此时开始收缩滑动窗口
            while (count == 0) {
                loc = sChar[left] - 'A';
                if (need[loc] > 0 && value[loc] == 0) {
                    count++;
                    if (min == -1 || i - left < min) {
                        start = left;
                        end = i;
                        min = i - left;
                    }
                }
                value[loc]++;
                left++;
            }
        }

        if (end == -1) {
            return "";
        }
        return s.substring(start,end+1);
    }
~~~



---



## 实现strStr()

```
实现 strStr() 函数。
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

提示：
    1 <= haystack.length, needle.length <= 104
    haystack 和 needle 仅由小写英文字符组成
```



有几种解法：暴力解法(BF算法)、KMP算法



### KMP算法

解题思路：字符串匹配问题，s表示被匹配的字符串，t表示需要匹配的模式，即在s匹配t，最直观的想法就是挨个匹配，匹配失败了再从s开始匹配处的下一个字符开始匹配，而t回溯到第一个字符，但是观察例子可以发现，有时候我们并不需要从s中开始匹配的下一个字符开始，t也不需要回溯到第一个字符，比如t是aab，s是aaab，在我们第一次匹配时，s和t都是从0（下标，后面也是）开始，匹配到2时匹配失败，s回溯到1，t回溯到0，再次一个一个的进行匹配，一共匹配了6次，但是再次判断时有了重复判断的情况，第二次判断时的第一个a的判断其实是多余的，我们可以根据第一次判断的结果推断出下一次判断t应该从哪里开始

~~~java
//字符串匹配问题，循序渐进，使用kmp算法，动态规划计算出next数组
    public int strStr(String haystack, String needle){
        if("".equals(needle)){
            return 0;
        }
        char[] chars1 = haystack.toCharArray(),chars2 = needle.toCharArray();
        int[] next = new int[chars2.length];

        //计算next数组
        next[0] = -1;
        for (int i = 1; i < next.length; i++) {
            int k = next[i-1];
            while (k != -1) {
                if (chars2[k] == chars2[i - 1]) {
                    next[i] = k+1;
                    break;
                }else{
                    k = next[k];
                }
            }
            if (k == -1) {
                next[i] = 0;
            }
        }

        int i = 0,j = 0;
        while (i < chars1.length && j < chars2.length) {
            if (chars1[i] == chars2[j]) {
                i++;
                j++;
            }else{
                j = next[j];
            }
            if (j == -1) {
                i++;
                j++;
            }
        }

        if (j == chars2.length) {
            return i-chars2.length;
        }
        return -1;
    }
~~~

---





## 最长公共前缀



```
     最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串“”。
提示：
    1 <= strs.length <= 200
    0 <= strs[i].length <= 200
    strs[i] 仅由小写英文字母组成
```



### 解法一：纵向查找

思想：纵向的遍历字符串数组中每个元素的当前字符，如果一个匹配不上则结束查找，所统计的长度就是最长公共前缀的大小

~~~java
public String longestCommonPrefix(String[] strs){
        char[][] chars = new char[strs.length][];
        int min = 201;

        for (int i = 0; i < strs.length; i++) {
            chars[i] = strs[i].toCharArray();
            if (min > chars[i].length) {
                min = chars[i].length;
            }
        }

        int i = 0;
        StringBuilder sb = new StringBuilder();
        while (i < min) {
            char c = chars[0][i];
            for (int j = 1; j < chars.length; j++) {
                if (chars[j][i] != c) {
                    return sb.toString();
                }
            }
            sb.append(c);
            i++;
        }

        return sb.toString();
    }
~~~



### 解法二：横向查找

思想：将字符串数组中两个元素进行对比，所得出的结果再和下一个元素进行对比，寻找最长公共前缀，最终所得出的结果就是整个数组所有元素的最长公共前缀

~~~java
public String longestCommonPrefix(String[] strs){
        int min = 201;
        char[][] chars = new char[strs.length][];
        StringBuilder prefix = new StringBuilder();
        char[] point = null;

        for (int i = 0; i < strs.length; i++) {
            chars[i] = strs[i].toCharArray();
            if (min > chars[i].length) {
                min = chars[i].length;
                point = chars[i];
            }
        }

        if (min == 0) {
            return "";
        }
        prefix.append(point);

        for (int i = 0; i < strs.length; i++) {
            int length = prefix.length();
            for (int j = 0; j < length; j++) {
                if (prefix.charAt(j) != chars[i][j]) {
                    prefix.delete(j,length);
                    break;
                }
            }
        }

        return prefix.toString();
    }
~~~

~~~java
//升级版横向查找
    public String longestCommonPrefix(String[] strs){
        if (strs == null || strs.length == 0) {
            return "";
        } else if (strs.length == 1) {
            return strs[0];
        }

        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            prefix = findCommonPrefix(prefix,strs[i]);
            if ("".equals(prefix)) {
                break;
            }
        }

        return prefix;
    }

    public String findCommonPrefix(String s1,String s2){
        char[] c1 = s1.toCharArray(),c2 = s2.toCharArray();
        int len = Math.min(c1.length,c2.length),loc = 0;

        for (; loc < len; loc++) {
            if (c1[loc] != c2[loc]) {
                break;
            }
        }

        return s1.substring(0,loc);
    }
~~~



### 解法三：分治法

思想：将数组分成两部分分别求最长公共前缀，再将两部分合并



### 解法四：二分查找

思想：以一个元素为查找范围，使用二分法找到它中间的元素，然后在其余所有字符串中检验当前找到的元素是否存在，如果有一些字符串不存在，则缩小范围，走下半区。如果全都存在，走上半区。

---





## 寻找重复数

~~~
给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。

你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。
~~~







# 链表



## 合并K个排序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。



### 解法一：最小堆（优先队列）

思想：开始时，维护一个k个元素的最小堆（k是数组中链表的个数），这k个元素就是每个链表的起始位置，然后每次取出堆顶，插入到结果链表中，再把堆顶的下一个元素放入堆顶，再调整堆，使之仍然满足最小堆，如果堆顶的下一个元素为null，则堆维护的元素个数减一。以此类推，直至堆为空

~~~java
public ListNode mergeKLists(ListNode[] lists){
        if (lists.length == 0) {
            return null;
        }
        int count = 0,k = lists.length;
        ListNode[] temp = new ListNode[k];
        ListNode res = new ListNode(),cur = res;
        for (int i = 0; i < k; i++) {
            //只有不为null时才算进个数里
            if (lists[i] != null) {
                temp[count++] = lists[i];
            }
        }

        //调整为小根堆
        for (int i = (count-2)/2; i >= 0; i--) {
            shift(temp,i,count);
        }

        while (count > 0) {
            cur.next = temp[0];
            cur = cur.next;
            temp[0] = temp[0].next;
            if (temp[0] == null) {
                count--;
                temp[0] = temp[count];
                temp[count] = null;
            }
            shift(temp,0,count);
        }

        return res.next;
    }

    public void shift(ListNode[] nodes,int cur,int n){
        int i = cur,j = 2*i+1;
        while (j < n) {
            if (j < n - 1 && nodes[j].val > nodes[j + 1].val) {
                j++;
            }

            if (nodes[i].val > nodes[j].val) {
                ListNode temp = nodes[i];
                nodes[i] = nodes[j];
                nodes[j] = temp;
                i = j;
                j = 2*i+1;
            }else
                break;
        }
    }
~~~



### 解法二：归并排序

思想：以归并排序的思想将数组中的每个链表两两进行排序，最终合成的链表也是有序的

~~~java
//想法：分治法，两两合并,没有使用递归的分治，而是采用希尔排序类似的以组为单位
    public ListNode mergeKLists(ListNode[] lists){
        if (lists.length == 0) {
            return null;
        }

        int k = lists.length,span = 2,l = span >> 1;
        while (l < k) {
            for (int i = 0; i < k - l; i+=span) {
                lists[i] = mergeTwo(lists[i],lists[i+l]);
            }
            l = span;
            span = span << 1;
        }

        return lists[0];
    }

    public ListNode mergeTwo(ListNode l1,ListNode l2){
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        }
        ListNode cur1 = l1,cur2 = l2,newHead = new ListNode(),pre = newHead,pre2;
        pre.next = l1;

        while (l1 != null && l2 != null) {
            if (l1.val > l2.val) {
                pre2 = l2.next;
                l2.next = l1;
                pre.next = l2;
                l2 = pre2;
            }else {
                l1 = l1.next;
            }
            pre = pre.next;
        }

        if (l1 == null && l2 != null) {
            pre.next = l2;
        }
        return newHead.next;
    }
~~~



___





## 排序链表

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。 

提示：

    链表中节点的数目在范围 [0, 5 * 104] 内
    -105 <= Node.val <= 105


进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？



### 解法一：自顶向下的归并排序

思想：所谓的自顶向下，就是使用分治法，将序列分为两半分别排序，递归的进行排序

~~~java
public ListNode sortList(ListNode head){
        if (head == null) {
            return null;
        }
        int len = 0,i = 0;
        ListNode temp = head;

        while (temp != null) {
            temp = temp.next;
            len++;
        }

        ListNode[] listNodes = new ListNode[len];
        temp = head;

        //注意细节，每个节点要切割开来
        while (temp != null) {
            listNodes[i] = temp;
            temp = temp.next;
            listNodes[i].next = null;
            i++;
        }
        sort(listNodes,0,len-1);

        return listNodes[0];
    }

    public void sort(ListNode[] listNodes,int left,int right){
        if(left >= right){
            return;
        }
        int center = left + (right-left)/2;
        sort(listNodes,left,center);
        sort(listNodes,center+1,right);

        listNodes[left] = mergeTwo(listNodes[left],listNodes[center+1]);
    }

    public ListNode mergeTwo(ListNode l1,ListNode l2){
        ListNode newHead = new ListNode(),pre,next;
        pre = newHead;
        newHead.next = l1;

        while (l1 != null && l2 != null) {
            if (l1.val > l2.val) {
                next = l2.next;
                l2.next = l1;
                pre.next = l2;
                pre = pre.next;
                l2 = next;
            }else{
                pre = l1;
                l1 = l1.next;
            }
        }

        if (l2 != null) {
            pre.next = l2;
        }

        return newHead.next;
    }
~~~

官方题解的写法没有使用额外的数组来存放链表节点，而是每次使用快慢指针来寻找一个链表的中间位置：

~~~java
public ListNode sortList(ListNode head) {
        return sortList(head, null);
    }

    public ListNode sortList(ListNode head, ListNode tail) {
        if (head == null) {
            return head;
        }
        if (head.next == tail) {
            head.next = null;
            return head;
        }
        ListNode slow = head, fast = head;
        while (fast != tail) {
            slow = slow.next;
            fast = fast.next;
            if (fast != tail) {
                fast = fast.next;
            }
        }
        ListNode mid = slow;
        ListNode list1 = sortList(head, mid);
        ListNode list2 = sortList(mid, tail);
        ListNode sorted = merge(list1, list2);
        return sorted;
    }

    public ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummyHead = new ListNode(0);
        ListNode temp = dummyHead, temp1 = head1, temp2 = head2;
        while (temp1 != null && temp2 != null) {
            if (temp1.val <= temp2.val) {
                temp.next = temp1;
                temp1 = temp1.next;
            } else {
                temp.next = temp2;
                temp2 = temp2.next;
            }
            temp = temp.next;
        }
        if (temp1 != null) {
            temp.next = temp1;
        } else if (temp2 != null) {
            temp.next = temp2;
        }
        return dummyHead.next;
    }
~~~



### 解法二：自底向上的归并排序

思想：自底向上，也就是从长度为1开始，将整个链表分割成一个个长度为1的子链表，然后每两个为一组归并排序，再合为一整个链表，合并完一次后让长度翻倍，再一次分割合并，直到长度大于链表的长度。注意实现细节，最后可能有链表没有和其他链表组队合并，所以最后一个链表的长度可能与当前分割的长度不同。另一个重点在于将整个链表分割成子链表和将子链表再合并成一个链表的操作，有许多细节需要把握。

实现：这里我是采用快慢指针的方法找到两个要合并的子链表，注意是割成子链表，合并成功后立马接回原链表中，再进行下一组的分割与合并

~~~java
public ListNode sortList(ListNode head){
        ListNode newHead = new ListNode(),cur1,cur2,pre1,pre2,next,temp;
        int l = 1,len = 0,count = 0;

        next = head;
        pre1 = null;
        pre2 = null;
        while (next != null) {
            next = next.next;
            len++;
        }

        newHead.next = head;
        while (l < len) {
            temp = newHead;
            next = newHead.next;
            while (next != null) {
                cur1 = next;
                cur2 = next;
                count = 0;
                while (count < l && cur2 != null) {
                    pre1 = cur2;
                    cur2 = cur2.next;
                    count++;
                    if (next != null) {
                        next = next.next;
                    }
                    pre2 = next;
                    if (next != null) {
                        next = next.next;
                    }
                }

                pre1.next = null;
                if (pre2 != null) {
                    pre2.next = null;
                }else
                    temp.next = cur1;
                temp.next = mergeTwo(cur1,cur2);
                while (temp.next != null) {
                    temp = temp.next;
                }
            }
            l <<= 1;
        }

        return newHead.next;
    }

    public ListNode mergeTwo(ListNode l1,ListNode l2){
        ListNode newHead = new ListNode(),pre = newHead,next;
        newHead.next = l1;

        while (l1 != null && l2 != null) {
            if (l1.val > l2.val) {
                next = l2.next;
                l2.next = l1;
                pre.next = l2;
                l2 = next;
                pre = pre.next;
            }else{
                pre = l1;
                l1 = l1.next;
            }
        }

        if (l2 != null) {
            pre.next = l2;
        }

        return newHead.next;
    }
~~~



___





## 复制带随机指针的链表

```
给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random
，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深
拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的
原节点的值。
新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，
并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表
中的指针都不应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。
那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。
返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
    val：一个表示 Node.val 的整数。
    random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
你的代码 只 接受原链表的头节点 head 作为传入参数。

提示：
    0 <= n <= 1000
    -104 <= Node.val <= 104
    Node.random 为 null 或指向链表中的节点
```



### 解法：哈希表

思想：首先我们先将原链表中的节点与一个编号联系上，比如第一个链表的编号就是0，第二个链表的编号是1，以此类推，这个步骤的作用后续构造新链表时我们会使用到。使用一个数组存放新链表当中的节点，是为了将节点与下标联系起来，构造时维护一个下标i，从0开始，然后从原链表的第一个节点开始构造，如果新链表数组中当前下标为i的元素不为空，那么直接将这个元素接入新链表中，如果为空，就创建一个节点并将原链表当前节点的值赋给这个新建的节点，注意要将创建出来的节点放入到数组当中，然后是构造这个新链表节点的随机指针，我们从原链表节点的哈希表中找到它的随即指针所指节点的下标，如果新链表数组中这个下标的元素存在，难么新链表当前节点的随机指针指向这个元素即可，如果不存在，就创建出来并赋值，然后放入到数组中对应下标的位置上。

~~~java
public Node copyRandomList(Node head){
        Map<Node,Integer> map = new HashMap<>();
        Node cur = head,newHead = new Node(-1),next = newHead;
        int count = 0;

        while (cur != null) {
            map.put(cur,count);
            cur = cur.next;
            count++;
        }
        Node[] temp = new Node[count];

        cur = head;
        count = 0;
        while (cur != null) {
            Node node = temp[count];
            if (node == null) {
                node = new Node(cur.val);
                temp[count] = node;
            }
            Integer randomNum = map.get(cur.random);
            if (randomNum != null ) {
                if (temp[randomNum] != null) {
                    node.random = temp[randomNum];
                }else{
                    node.random = new Node(cur.random.val);
                    temp[randomNum] = node.random;
                }
            }else
                node.random = null;

            count++;
            next.next = node;
            next = next.next;
            cur = cur.next;
        }

        return newHead.next;
    }

class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
~~~

---



# 二叉树

```
给定一个二叉树的根节点root，返回它的中序遍历
提示：
    树中节点数目在范围 [0, 100] 内
    -100 <= Node.val <= 100
进阶: 递归算法很简单，你可以通过迭代算法完成吗？
```



## 二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。 



### 解法一：递归

二叉树的中序遍历，算法基本功，递归的遍历二叉树

~~~java
List<Integer> res;
    public List<Integer> inorderTraversal(TreeNode root){
        res = new ArrayList<>();
        dfs(root);
        return res;
    }
    public void dfs(TreeNode node){
        if (node == null) {
            return;
        }

        dfs(node.left);
        res.add(node.val);
        dfs(node.right);
    }
~~~



### 解法二：堆栈

使用堆栈的解法，有些细节需要注意

~~~java
public List<Integer> inorderTraversal(TreeNode root){
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        List<Integer> res = new ArrayList<>();
        while (!stack.isEmpty() || cur != null) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }

            cur = stack.pop();
            res.add(cur.val);
            cur = cur.right;
        }
        return res;
    }
~~~



### 解法三：Morris算法

**解题思路：**很巧妙的一种想法，利用中序遍历的性质：**先左子树后当前节点最后右子树，那么遍历得到的序列当中当前节点的父节点一定会在当前节点的右子树之后。**利用这样一种先后顺序，将空的右子树利用起来，找到当前节点的左子树中最右边的节点，将其的右子树连接到当前节点，那么按照中序遍历的时候一定会走回到当前节点。具体的做法如下：

1. 检查当前节点是否有左子树，没有的话就将当前节点的值放入结果集中，走到当前节点的右子树上；如果有左子树，执行后面操作。

2. 找到左子树中最右边的节点，执行结果有两种：

   ①找到最右边的节点，它的右子树为空，执行步骤3

   ②寻找过程中回到当前节点，这一结果是由于我们后续的操作所造成的，说明当前节点的左子树已经遍历过了，走到当前节点的右子树上去

3. 将最右边的节点的右子树置为当前节点，走到当前节点的左子树上去

执行上述过程，直到当前节点为空为止。



**算法实现：**

~~~java
//Morris算法
    public List<Integer> inorderTraversal(TreeNode root){
        TreeNode cur = root,pre = null,search;
        List<Integer> res = new ArrayList<>();
        while (cur != null) {
            if (cur.left != null) {
                search = cur.left;
                while (search != null && search != cur) {
                    pre = search;
                    search = search.right;
                }
                if (search == cur) {
                    res.add(cur.val);
                    cur = cur.right;
                }else{
                    pre.right = cur;
                    cur = cur.left;
                }
            }else{
                res.add(cur.val);
                cur = cur.right;
            }
        }
        return res;
    }
~~~

---





## 二叉树的锯齿形层次遍历

```
给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。
（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
提示：
    树中节点数目在范围 [0, 2000] 内
    -100 <= Node.val <= 100
```



### 解法一：堆栈



**解题思路：**令层数从1开始，维护两个堆栈，一个存放奇数层的节点，一个存放偶数层的节点。奇数层时，顺序出栈奇数栈的节点，将节点的值加入结果集中，然后按照右左的顺序将子树放入到偶数栈中；偶数层时，顺序出栈偶数栈的节点，放入结果集中，然后按照左右的顺序将其子树放入到奇数栈中。



**算法实现：**

~~~java
public List<List<Integer>> zigzagLeveOrder(TreeNode root){
        Stack<TreeNode> s1 = new Stack<>(),s2 = new Stack<>();
        TreeNode node;
        List<List<Integer>> res = new ArrayList<>();
        if (root != null) {
            s1.push(root);
        }
        int count = 1;
        while (!s1.isEmpty() || !s2.isEmpty()) {
            List<Integer> list = new ArrayList<>();
            if ((count & 1) == 1) {
                while (!s1.isEmpty()) {
                    node = s1.pop();
                    list.add(node.val);
                    if (node.left != null) {
                        s2.push(node.left);
                    }
                    if (node.right != null){
                        s2.push(node.right);
                    }
                }
            }else{
                while (!s2.isEmpty()) {
                    node = s2.pop();
                    list.add(node.val);
                    if (node.right != null) {
                        s1.push(node.right);
                    }
                    if (node.left != null) {
                        s1.push(node.left);
                    }
                }
            }
            res.add(list);
            count++;
        }
        return res;
    }
~~~





### 解法二：DFS递归



**解题思路：**层数从0开始，注意，和上题不同，递归的将结果加入到结果集中，动态的创建结果中的List，具体做法是传递节点和层数，如果传递的节点为null，则直接返回。如果结果不为空执行下列操作：检查结果集中是否有当前层数的List，如果没有，则创建一个List加入到结果集中，然后判断当前层数，如果当前是偶数层就正常放入List中，如果是奇数层，那么就要逆序来放，在java中的List的操作是放到List里下标为0的位置上。



**算法实现：**

~~~java
List<List<Integer>> res;
    public List<List<Integer>> zigzagLevelOrder(TreeNode root){
        res = new ArrayList<>();
        dfs(root,0);
        return res;
    }

    public void dfs(TreeNode node,int depth){
        if (node == null) {
            return;
        }
        List<Integer> list;
        if (res.size() <= depth) {
            res.add(new ArrayList<>());
        }
        list = res.get(depth);
        if ((depth & 1) == 0) {
            list.add(node.val);
        }else
            list.add(0,node.val);

        dfs(node.left,depth+1);

        dfs(node.right,depth+1);
    }
~~~

---



## 从前序与中序遍历序列构造二叉树

```
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历，
inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
```



### 解法一：分治

**解题思路：**观察前序遍历与中序遍历的联系，前序遍历的第一个节点对应到中序遍历中该节点的位置，可以发现中序遍历中该节点左边的属于该节点的左子树部分，右边的是该节点的右子树部分，可以分别递归构造左子树和右子树，只需要改变节点的界限

**算法实现：**

~~~java
	int pre;
    int[] preorder,inorder;
    public TreeNode buildTree(int[] preorder,int[] inorder){
        pre = 0;
        this.preorder = preorder;
        this.inorder = inorder;
        return build(0,preorder.length-1);
    }

    public TreeNode build(int left,int right){
        if (left > right || pre == preorder.length) {
            return null;
        }
        if (left == right) {
            return new TreeNode(preorder[pre++]);
        }

        TreeNode cur = new TreeNode(preorder[pre++]);
        int loc = left;
        while (loc <= right) {
            if (inorder[loc] == cur.val) {
                break;
            }
            loc++;
        }
        cur.left = build(left,loc-1);
        cur.right = build(loc+1,right);
        return cur;
    }
~~~

还可以使用哈希表对查找过程优化：

~~~java
	int pre;
    int[] preorder,inorder;
    Map<Integer,Integer> map;
    public TreeNode buildTree(int[] preorder,int[] inorder){
        pre = 0;
        this.preorder = preorder;
        this.inorder = inorder;
        map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i],i);
        }
        return build(0,preorder.length-1);
    }

    public TreeNode build(int left,int right){
        if (left > right || pre == preorder.length) {
            return null;
        }
        if (left == right) {
            return new TreeNode(preorder[pre++]);
        }

        TreeNode cur = new TreeNode(preorder[pre++]);
        int loc = map.get(cur.val);
        cur.left = build(left,loc-1);
        cur.right = build(loc+1,right);
        return cur;
    }
~~~





### 解法二：堆栈

**解题思路：**我们观察前序遍历可以发现，在前序遍历中，两个相邻节点之间的关系只有三种：后是前的左子树，后是前的右子树，后是前的某个父节点的右子树。如果我们知道具体是哪一种情况，我们就可以构建出来二叉树了，这时候就需要使用中序遍历序列了，我们在中序序列中维护一个指针，一开始指向第一个元素，如果当前构造的节点值等于这个指针所指的值，那么说明当前节点是目前最左边的节点，没有左子树了，反之则代表有左子树。如果没有左子树，让中序指针加一，由于要判断后一个节点（前序遍历中）是当前节点还是父节点的右子树，我们需要维护一个存放父节点的堆栈，入栈操作在判断有左子树后进行，在中序指针加一后，判断堆栈栈顶节点的值与当前中序指针的值是否相等，如果相等，则说明当前节点没有右子树，因为在中序遍历中它的下一个节点就是父节点了，所以我们将当前节点置为栈顶节点并弹栈，中序指针后移，重复判断过程直到不相等，然后将前序遍历中的下一个节点接到当前节点的右子树上，当前节点再移到右子树上。

**算法实现：**

~~~java
	public TreeNode buildTree(int[] preorder,int[] inorder){
        Stack<TreeNode> stack = new Stack<>();
        int pre = 0,in = 0;
        TreeNode cur = new TreeNode(preorder[pre++]),root = cur;
        while (pre < preorder.length) {
            //判断当前节点是否有左子树，即它的下一个节点
            //是不是当前中序遍历第一个
            if (inorder[in] != cur.val) {
                cur.left = new TreeNode(preorder[pre++]);
                stack.push(cur);
                cur = cur.left;
            }else{
                in++;
                while (!stack.isEmpty() && stack.peek().val == inorder[in]) {
                    in++;
                    cur = stack.pop();
                }
                cur.right = new TreeNode(preorder[pre++]);
                cur = cur.right;
            }
        }
        return root;
    }
~~~



### 解法三：递归

**解题思路：**递归的构造二叉树，使用一个stop值来判断递归是够终止，先构造当前前序序列的节点，然后递归构造它的左子树，将当前节点的值传递为stop，左子树构造完了之后，递归构造右子树，将当前的stop传递为递归中的stop，递归的返回条件是当前的中序序列值等于stop，让中序指针后移，然后return空值。

**算法实现：**

~~~java
	int pre,in;
    int[] preorder,inorder;
    public TreeNode buildTree(int[] preorder,int[] inorder){
        pre = 0;in = 0;
        this.preorder = preorder;this.inorder = inorder;
        return build(Integer.MAX_VALUE);
    }
    //给左子树传递当前节点的值，因为如果
    //左子树为空，可以更新中序遍历的当前
    //值，给右子树传递当前节点的stop值，
    //这个值很可能是当前节点的父节点的值
    //如果当前节点的右节点为空，那么就要
    //在进入右节点的操作中更新中序遍历的
    //值，因为中序遍历中当前节点的下一个
    //就是父节点
    public TreeNode build(int stop){
        if (pre >= preorder.length) {
            return null;
        }
        if (inorder[in] == stop) {
            in++;
            return null;
        }

        TreeNode node = new TreeNode(preorder[pre++]);
        node.left = build(node.val);
        node.right = build(stop);
        return node;
    }
~~~





# 其他



## 天际线问题

**题目描述**

```
城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。

每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：

    lefti 是第 i 座建筑物左边缘的 x 坐标。
    righti 是第 i 座建筑物右边缘的 x 坐标。
    heighti 是第 i 座建筑物的高度。

你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。

天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],...] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。

注意：输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]
```

示例1：

```
输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
```

示例2：

```
输入：buildings = [[0,2,3],[2,5,3]]
输出：[[0,3],[5,0]]
```

提示：

    1 <= buildings.length <= 10^4
    0 <= lefti < righti <= 2^31 - 1
    1 <= heighti <= 2^31 - 1
    buildings 按 lefti 非递减排序

### 解法一：扫描线+优先队列

#### 解题思路

仔细观察，不难发现，所有的关键点都在一栋楼（即buildings的一个元素）的左右边界出现。因此可以以左右边界为突破口，来寻找关键点。确定了从左右边界开始找，左右边界就是关键点的横坐标，如何确定纵坐标就成为了关键。在确定了纵坐标后，横坐标就是经过当前点的区间的最高值（不包含右端点为当前横坐标的情况）。

#### 代码

```java
	public List<List<Integer>> getSkyline(int[][] buildings) {
        int n = buildings.length, l = 0;
        //梳理一下，一共分为几步
        //1、将所有可能的关键点的横坐标存储起来，并且按照大小顺序存储起来
        int[] temp = new int[n << 1];
        for (int i = 0; i < n; i++) {
            temp[l++] = buildings[i][0];
            temp[l++] = buildings[i][1];
        }
        Arrays.sort(temp);

        //2、遍历集合中的可能关键点，并维护优先队列，队列中存放的是元素的右边界和高度，并且按照高度形成大根堆
        PriorityQueue<int[]> queue = new PriorityQueue<>((x, y) -> y[1] - x[1]);
        int loc = 0;
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < l; i++) {
            //先将可能的边界加入优先队列（堆）中
            while (loc < n && buildings[loc][0] <= temp[i]) {
                queue.offer(new int[]{buildings[loc][1], buildings[loc][2]});
                loc++;
            }
            //去掉不符合条件的堆顶，范围的右边界小于当前关键点的横坐标时，去除这个范围
            while (!queue.isEmpty() && queue.peek()[0] <= temp[i])
                queue.poll();
            //更新结果，注意要判断是否与前一个结果相同
            int[] peek = queue.peek();
            List<Integer> node = new ArrayList<>();
            node.add(temp[i]);
            if (peek != null)
                node.add(peek[1]);
            else
                node.add(0);
            if (res.isEmpty() || !res.get(res.size() - 1).get(1).equals(node.get(1)))
                res.add(node);
        }

        return res;
    }
```





## 柱状图中最大的矩形

### 思路

要找出最大的矩形，即矩形的面积，就可以以每个元素为高，就算出矩形的面积，那么我们就需要统计出以每个元素为高的左端点和右端点。

可以使用单调栈以实现O(n)复杂度计算出每个元素的左端点和右端点，具体操作如下：

* 单调栈中存放的是单调非递减的元素，遍历到当前元素i时，先检查栈顶的元素，如果栈顶的元素大于当前元素，则需要出栈。并且当前元素是栈顶元素右侧第一个小于其的元素（如果有别的元素在当前元素之前就小于栈顶元素了，那么栈顶元素就已经出栈了，不会还保留在栈中），所以记录栈顶元素的右端点为当前元素。
* 将栈中所有大于当前的元素出栈并且设置了右端点之后，就需要记录当前元素的左端点了，因为现在单调栈中保留的栈顶元素是小于当前元素，并且是当前元素左边第一个小于其的（如果别的元素也小于，并且更接近当前元素的话，那么现在这个栈顶节点就不会存在于栈中了，而是在遍历当那个元素时，当前栈顶元素就被出栈了，由此可证明当前栈顶的元素就是左边第一个小于当前元素的元素）。如果栈中没有其他元素了的话，那么说明当前元素是最小的，左端点设置为-1。
* 然后将当前元素加入栈中。
* 遍历完所有元素之后，如果栈不为空，那么说明栈中的元素的右侧没有比其更小的元素，所以将此时栈中所剩余的元素的右端点全部设置为n，即数组的长度。





# 周赛



## 坐上公交车的最晚时间

> 第82场双周赛---第二题



### 题目描述

```
 给你一个下标从 0 开始长度为 n 的整数数组 buses ，其中 buses[i] 表示第 i 辆公交车的出发时间。同时给你一个下标从 0 开始长度为 m 的整数数组 passengers ，其中 passengers[j] 表示第 j 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。

 给你一个整数 capacity ，表示每辆公交车 最多 能容纳的乘客数目。

 每位乘客都会搭乘下一辆有座位的公交车。如果你在 y 时刻到达，公交在 x 时刻出发，满足 y <= x  且公交没有满，那么你可以搭乘这一辆公交。最早 到达的乘客优先上车。

 返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。

 注意：数组 buses 和 passengers 不一定是有序的。
```



**示例1：**

```text
输入：buses = [10,20], passengers = [2,17,18,19], capacity = 2
输出：16
解释：
第 1 辆公交车载着第 1 位乘客。
第 2 辆公交车载着你和第 2 位乘客。
注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。
```

**示例2：**

```
输入：buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2
输出：20
解释：
第 1 辆公交车载着第 4 位乘客。
第 2 辆公交车载着第 6 位和第 2 位乘客。
第 3 辆公交车载着第 1 位乘客和你。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/the-latest-time-to-catch-a-bus
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

**提示：**

- n == buses.length
- m == passengers.length
- 1 <= n, m, capacity <= 105
- 2 <= buses[i], passengers[i] <= 109
- buses 中的元素 互不相同 。
- passengers 中的元素 互不相同 。



### 分析

题目所要求的是”你“在已有公交车出发时间、公交车载量、乘客到达时间的基础上，所能搭乘公交车离开的最大时间。要找到每辆公交车出发前，还有座位的情况下，乘客到达的空隙最大值。

如果乘客在一个公交车的出发时间内到达，但是在他到达时，公交车就已经达到了最大乘客量，那么他只能等下一辆公交车。

如果一辆公交车的出发时间之内座位没有坐满，那么这段时间内满足题目要求的最大值就是公交车开出的时间。

还需要注意乘客与乘客之间有没有空位可以让我们插入。



### 代码

```java
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity){
        int m = buses.length,n = passengers.length,res = 1,cnt = 0;
        Arrays.sort(buses);
        Arrays.sort(passengers);

        int j = 0;
        //使用set是为了判断是否有乘客在buses[i]开出时到达
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < n; i++) {
            set.add(passengers[i]);
        }
        for (int i = 0; i < m; i++) {
            while (cnt < capacity && j < n && passengers[j] <= buses[i]) {
                //只有第一个到达的乘客和不连续到达的乘客之间可以插
                //入，也就是插入到当前乘客的前一个时间点
                if(j == 0 || passengers[j-1] != passengers[j]-1)
                    res = passengers[j]-1;
                j++;
                cnt++;
            }
            if(cnt < capacity && !set.contains(buses[i]))
                res = buses[i];
            cnt = 0;
        }
        return res;
    }
```





## 最小差值平方和

> 第82场双周赛



### 题目描述

~~~
给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度为 n 。

数组 nums1 和 nums2 的 差值平方和 定义为所有满足 0 <= i < n 的 (nums1[i] - nums2[i])2 之和。

同时给你两个正整数 k1 和 k2 。你可以将 nums1 中的任意元素 +1 或者 -1 至多 k1 次。类似的，你可以将 nums2 中的任意元素 +1 或者 -1 至多 k2 次。

请你返回修改数组 nums1 至多 k1 次且修改数组 nums2 至多 k2 次后的最小 差值平方和 。

注意：你可以将数组中的元素变成 负 整数。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/minimum-sum-of-squared-difference
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
~~~



**示例1：**

~~~
输入：nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0
输出：579
解释：nums1 和 nums2 中的元素不能修改，因为 k1 = 0 和 k2 = 0 。
差值平方和为：(1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579 。
~~~

**示例2：**

~~~
输入：nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1
输出：43
解释：一种得到最小差值平方和的方式为：
- 将 nums1[0] 增加一次。
- 将 nums2[2] 增加一次。
最小差值平方和为：
(2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43 。
注意，也有其他方式可以得到最小差值平方和，但没有得到比 43 更小答案的方案。
~~~

**提示：**

    n == nums1.length == nums2.length
    1 <= n <= 105
    0 <= nums1[i], nums2[i] <= 105
    0 <= k1, k2 <= 109



### 分析

首先，我们要仔细的审题，从题目中得出有效信息。这个题目让我们求最小差值平方和，要让平方和最小，就得控制差值，那么**怎么控制差值才能得到最小平方和呢？**

答案是控制差值的绝对值尽可能小，并且，从整体的角度来思考，为了让整体的结果最小，修改差值最大的元素效果最好，比如有两个差值：差值绝对值为4和差值的绝对值为5，只有一个操作数，对哪个操作效果好？当然是对5操作好，因为5->4，平方和减少了9，而如果对4进行操作，平方和只减少了7。

第二点，题目给我们的操作是两个数值，分别表示可以对数组1和数组2进行的操作次数。但此题目要求最小的平方和，那么也就是差值的绝对值最小就可以，仔细思考一下不难发现对数组1和数组2的操作效果其实是一样的，都是可以让差值的绝对值减小1。因此，我们只需要将两部分的值统一来考虑就可以了，统一考虑成：让数组中的某一对元素的差值的绝对值减1。



**以下为了便于描述，统一将差值的绝对值称为差值**



### 解法一：贪心

我们可以从最大差值开始进行减1







## 按位或最大的最小子数组长度

> 第87场双周赛



### 题目描述

~~~
给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。

    换言之，令 Bij 表示子数组 nums[i...j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 max(Bik) ，其中 i <= k <= n - 1 。

一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。

请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。

子数组 是数组里一段连续非空元素组成的序列。
~~~



**示例1：**

~~~
输入：nums = [1,0,2,1,3]
输出：[3,3,2,2,1]
解释：
任何位置开始，最大按位或运算的结果都是 3 。
- 下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。
- 下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。
- 下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。
- 下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。
- 下标 4 处，能得到结果 3 的最短子数组是 [3] 。
所以我们返回 [3,3,2,2,1] 。
~~~



**示例2：**

~~~
输入：nums = [1,2]
输出：[2,1]
解释：
下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。
下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。
所以我们返回 [2,1] 。
~~~



**提示：**

* `n == nums.length`
* `1 <= n <= 105`
* `0 <= nums[i] <= 10^9`



### 题目分析





### 解法一：维护位为1的数组





### 解法二：更加通用的模板

该模板可以做到

    求出所有子数组的按位或的结果，以及值等于该结果的子数组的个数。
    求按位或结果等于任意给定数字的子数组的最短长度/最长长度。

末尾列出了一些题目，均可以用该模板秒杀。

思考：对于起始位置为 iii 的子数组的按位或，至多有多少种不同的结果？

* 根据或运算的性质，我们可以从 x=nums[i]x=\textit{nums}[i]x=nums[i] 开始，不断往右扩展子数组，按位或的结果要么使 x 不变，要么让 x 的某些比特位的值由 0 变 1。最坏情况下从 x=0 出发，每次改变一个比特位，最终得到 2^29−1<10^9，因此至多有 30^30 种不同的结果。这意味着**我们可以递推计算所有按位或的结果**。

* 另一个结论是，相同的按位或对应的子数组右端点会形成一个连续的区间，从而保证下面去重逻辑的正确性（这一性质还可以用来统计按位或结果及其对应的子数组的个数）。

据此，我们可以倒着遍历 nums，在遍历的同时，用一个数组 ors 维护以 i 为左端点的子数组的按位或的结果，及其对应的子数组右端点的最小值。继续遍历到 nums[i−1] 时，我们可以把 nums[i−1] 和 ors 中的每个值按位或，合并值相同的结果。

这样在遍历时，ors 中值最大的元素对应的子数组右端点的最小值，就是要求的最短子数组的右端点。

注：下面代码用到了原地去重的技巧，如果你对此并不熟悉，可以先做做 26. 删除有序数组中的重复项。

~~~
class Solution {
    public int[] smallestSubarrays(int[] nums) {
        var n = nums.length;
        var ans = new int[n];
        var ors = new ArrayList<int[]>(); // 按位或的值 + 对应子数组的右端点的最小值
        for (int i = n - 1; i >= 0; --i) {
            ors.add(new int[]{0, i});
            var k = 0;
            for (var or : ors) {
                or[0] |= nums[i];
                if (ors.get(k)[0] == or[0])
                    ors.get(k)[1] = or[1]; // 合并相同值，下标取最小的
                else ors.set(++k, or);
            }
            ors.subList(k + 1, ors.size()).clear();
            // 本题只用到了 ors[0]，如果题目改成任意给定数值，可以在 ors 中查找
            ans[i] = ors.get(0)[1] - i + 1;
        }
        return ans;
    }
}
~~~



我写的版本：

~~~java
class Solution{
    public int[] smallestSubarrays(int[] nums){
        int n = nums.length;
        List<int[]> temp = new ArrayList<>();
        int[] res = new int[n];
        for (int i = n-1; i >= 0; i--) {
            //第一个元素是按位或的值，第二个元素是按位或得到的最小下标
            temp.add(new int[]{0,i});
            int k = 0;
            for (int[] a : temp) {
                a[0] |= nums[i];
                if (temp.get(k)[0] == a[0]) {
                    //或运算之后值相同，但当前数组a的最小下标肯定是小于等于前面的数组的
                    //因为是按照顺序添加进来的，所以覆盖掉前面的最小下标
                    temp.get(k)[1] = a[1];
                }else{
                    //去重操作，将当前数组放到应该放的位置
                    k++;
                    temp.set(k,a);
                }
            }
            //将后面重复的数组截取掉，避免影响到下一次循环
            temp.subList(k+1,temp.size()).clear();

            res[i] = temp.get(0)[1] - i + 1;
        }

        return res;
    }
}
~~~





## 使数组相等的最小开销

> 第316场周赛t3

### 解法一：枚举+考察变化量

![image-20221027225306618](D:\文档\学习笔记\专业方向\算法\算法题解.assets\image-20221027225306618-16668823891931.png)

解释：

**有cost[0]这么多的开销要增加nums[1]-nums[0] **

​	是因为第一个元素需要从nums[0]增加到nums[1]，所以需要增加cost[0] * (nums[1]-nums[0])的开销

**有sumCost-cost[0] 这么多的开销要减少nums[1]-nums[0]**

​	是因为nums[1]是大于nums[0]的，所以其他元素到nums[1]的开销肯定比nums[0]小
