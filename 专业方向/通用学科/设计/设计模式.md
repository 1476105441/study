# 设计模式原则



## 单一职责原则

> 就一个类而言，应该仅有一个引起它变化的原因

### 例子

设计俄罗斯方块游戏，如何将代码进行分类？



可以将代码分成两个部分，**游戏逻辑**和**界面展示**，游戏逻辑和界面展示之间并没有太大的关系，所以可以拆分成两个类来单独设计。



### 要点

* 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。
* 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。
* 如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。





## 开闭原则

> 软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。



### 要点

* 开闭原则两个特征，一是对于扩展是开放的，另一个是对于更改是封闭的。
* 无论模块是多么的**封闭**，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。
* 在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。
* 面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。
* 开闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的哪些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。





## 依赖倒转原则

> 高层模块不应该依赖低层模块。两个都应该依赖抽象。
>
> 抽象不应该依赖细节。细节应该依赖抽象。



高层模块依赖低层模块的情况：

​	面向过程开发时，为了使得代码可以服用，一般都会把常用代码写成许许多多的程序库，这样在做新项目时，去调用这些低层的函数就可以了，比如访问数据库的函数。不过这样子，如果业务逻辑的高层模块都是一样的，但客户却希望使用不同的数据库或存储信息方式，这时就麻烦了，高层模块都是与低层的访问数据库绑定在一起的，没办法服用这些高层模块。





## 里式替换原则

> 子类型必须能够替换掉它们的父类型



### 要点

* 里式替换原则主要是对于继承关系来说的，是继承所应该遵守的一种规范。





## 迪米特法则

> 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要另一个类的某一个方法的话，可以通过第三者转发这个调用。



### 要点

* 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。
* 迪米特法则的根本思想，是强调了类之间的松耦合。
* 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。



## 合成/聚合复用原则

> 尽量使用合成/聚合，尽量不要使用类继承。



### 要点

* 优先使用对象的合成/聚合将有助于你保持每个类被封装，并被击中在单个任务上。这样类和类的继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。



# 工厂模式



## 简单工厂模式

简单工厂模式的职责是专门负责创建对象，这样，就不用在业务代码中进行繁琐的判断，起到解耦合的作用



### 例子

需求：实现一个计算器功能



#### 1、简单实现
做法：在客户端直接判断，然后进行计算。

缺点：每次修改，都要直接修改业务代码，耦合性太强，如果多个地方都需要使用计算功能，则代码重复很多。



#### 2、封装成类
做法：将计算过程抽象到Operation类中。

缺点：所有的运算集中在一个类中，耦合性高，每次新加运算方法，都可能直接修改到其他运算方法。



#### 3、继承和多态

做法： 抽象出Operation类，定义操作数和计算结果的抽象方法，创建不同的子类实现不同的计算方法。

缺点：需要在客户端做判断，并选择创建不同的Operation子类，与方法一类似。



#### 4、结合简单工厂模式

做法：在方法三的基础上，定义一个类，专门负责创建Operation子类，将客户端中所需要做的逻辑判断转移到此类中，这个类就称为工厂类。





## 工厂方法模式





## 抽象工厂模式

> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。



### 结构



![image-20221028195644502](D:\文档\学习笔记\基础\设计模式\设计模式.assets\image-20221028195644502-16669582062261.png)



### 优缺点

优点

* 易于交换产品系列，只需要改变具体工厂即可使用不同的产品配置。
* 让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。

缺点

* 如果要增加工厂生产的类，要进行多处修改，增加多个类。
* 如果多个客户端要使用工厂生产的类，每次都要创建一个所需要的工厂类。





# 策略模式



## 例子

商场收银系统

**需求：**输入单价和数量，计算出来总价，要适应于商场各类活动的场合。



### 1、简单实现

做法：直接再客户端进行计算。

缺点：没有考虑到各种促销情况。



### 2、增加判断

做法：在客户端中进行判断，选择不同的打折情况进行计算。

缺点：在客户端操作，耦合度太高，并且不利于更改，促销活动可以有很多类似的处理，但是都只能通过增加判断条件的方式来增加处理情况，扩展十分麻烦。



### 3、抽象出类+简单工厂

做法：抽取出一个抽象类CashSuper，定义计算最终费用的方法，定义不同策略的实现类，如正常收取费用、打折、返现等策略，计算出不同的最终费用。使用简单工厂模式来创建不同的计算方法类。

缺点：算法时常变动，导致工厂类中的代码也需要频繁的修改。



### 4、策略模式

做法：在方法三的基础上，去掉工厂模式，封装一个策略上下文类，里面持有一个当前使用的策略（所以叫做上下文），对外暴露一个调用方法的接口，调用当前策略进行处理，将结果返回。

缺点：选择哪个策略，又交由客户端来处理了，又回到了前面几种操作的情况。



### 5、策略模式+简单工厂

做法：在方法四的基础上，策略上下文类再充当一个简单工厂的角色，由策略上下文类来决定使用哪个策略。



对比方法五和方法三，在修改程度上，即便是加上了策略模式，修改策略的时候，工厂类还是要频繁的修改，在此方面策略模式并没有改进。方法五取得进步的地方是在客户端代码中，只需要认识策略上下文对象，而简单工厂模式则需要认识工厂类和策略类，这在一定程度上起到了解耦合的作用。



### 总结

* 策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。
* 策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为，继承有助于析取出这些算法中的公共功能。
* 策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。
* 当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句。
* 策略模式即使用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
* 基本的策略模式中，选择所用的具体实现的职责由客户端对象承担，并转给策略模式的Context对象。





# 模板方法模式

> 定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。







# 原型模式

> 用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象。



## 要点

* 原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。
* 使用克隆方法不需要







# 外观模式

> 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。



## 个人理解

外观模式就是将功能的具体实现封装在一个类的内部，对外只提供简单的接口以供使用。







# 建造者模式

> 将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。





# 观察者模式

> 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主体对象。这个主题对象再状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。





# 状态模式

> 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。



## 结构

![image-20221028213337749](D:\文档\学习笔记\基础\设计模式\设计模式.assets\image-20221028213337749.png)



## 要点

* 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。
* 好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。
* 状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。
* 当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变他的行为时，就可以考虑使用状态模式了。





# 适配器模式

> 将一个累的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。



## 要点

* 系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。





# 桥接模式

> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。



## 要点

* 什么叫抽象与它的实现分离，这并不是说，让抽象类与其派生类分离，因为这没有意义。实现指的是抽象类和它的派生类用来实现自己的对象。
* 另一个理解：实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少他们之间的耦合。
* 只要深入理解了设计原则，很多设计模式其实就是原则的应用而已，或许在不知不觉中就在使用设计模式了。







# 命令模式

> 将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。



## 优点

* 它能较容易地设计一个命令队列。
* 在需要的情况下，可以较容易地将命令记入日志。
* 允许接收请求的一方决定是否要否决请求。
* 可以容易地实现对请求的撤销和重做。
* 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。
* 命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。

## 要点

* **敏捷开发原则告诉我们，不要为代码添加基于猜测的实际不需要的功能**。
* 如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。







# 职责链模式

> 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。







# 中介者模式

> 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。



## 要点

* 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多子类的场合。







# 享元模式

> 运用共享技术有效地支持大量细粒度的对象。







# 解释器模式

> 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。



## 结构

![image-20221030233241583](D:\文档\学习笔记\基础\设计模式\设计模式.assets\image-20221030233241583.png)



## 要点

* 解释器模式要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。
* 正则表达式就是解释器模式的一种应用，解释器为正则表达式定义了一个文法，如何表示一个特定的正则表达式，以及如何解释这个正则表达式。
* 像IE、Firefox这些浏览器，其实也是在解释HTML文法，将下载到客户端的HTML标记文本转换成网页格式显示到用户。当然，浏览器的程序编写起来要复杂的多。
* 通常当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。
* 解释器模式就是将一句话转变成为实际的命令程序执行而已，比如对机器人说：“哥们儿，向前走10步，然后左转90度，再向前走5步。”
* 不用解释器模式本来也可以分析，但通过继承抽象表达式的方式，由于依赖倒转原则，使得对文法的扩展和维护都带了方便。



## 优点

* 用了解释器模式，就意味着可以很容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可以使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树种各个节点的类的实现大体类似，这些类都易于直接编写。



## 不足

* 解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。





# 访问者模式

> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下自定义作用于这些元素的新操作。
